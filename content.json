[{"title":"创业公司面试题","date":"2017-04-11T05:59:43.000Z","path":"2017/04/11/创业公司面试题/","text":"1、有没有用过MVVM框架？2、es6你懂多少（主问promises，对象字面量）？答： Promises 是处理异步操作的一种模式 3、ng自定义指令中compile和link的区别？答：两者都是可以对指令的模板进行转换，link作用在于模型和视图之间建立关联。 conpile种必须要在函数体内返回一个return ,而这个return就是link 4、浏览器缓存答：第一种方法：前端修改文件名称后缀添加时间戳和随机数，这样会修改文件名 第二种方法：（后台把状态码304指向200，达到消除缓存） 301 才是重定向 5、ng-if和ng-show/ng-hide有什么区别实现的原理是什么？（不是问怎么用）6、给你一个PSD图，你能把他还原出来吗？7、TypeScript有了解过吗？（公司使用ng2和TypeScript作开发）答：类似于es6，单语法上有区别 8、要把一个伪数组转为真数组？答：[].slice.call(obj) 当时答了[].push.call(obj)…. 我也记得有一个东西可以转换，但真的自己一个人想和被问到两码事 9、说说DOM的一些基本API？10、documentfragment答：当页面需要加载10000个div时，用这个方法临时占位，可以提高浏览器性能，具体百度 11、简单说说原型链继承？继承过来的属性和方法能否被修改答：原型链继承就是通过父对象的实例赋值给子对象的原型，实现子对象的实例可以获取父对象的所有实例属性和方法以及原型属性和方法，继承过来的属性和方法当遇到是引用类型的时候会出现共享问题，也就是子对象实例可以修改到父对象的属性和方法 真想不到当年我把这个教人教得如何如何，还自己写blog分析，当真正面试被问到，我竟然答错了这个最基础的问题，笑了，估计要败也是败在这里。","tags":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"es6this箭头函数","date":"2017-04-10T13:53:53.000Z","path":"2017/04/10/es6this箭头函数/","text":"1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var test1=()=&gt;&#123; console.log(this.name,this); &#125; window.name = \"obj window\"; class P&#123; constructor()&#123; this.name = \"class p\"; &#125; func()&#123; var test2 = () =&gt;&#123; console.log(this.name,this); &#125;; function test3()&#123; console.log(this); &#125; test1();//obj window test2();//class p test3();//undefined &#125; &#125; var p = new P(); p.func(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; js中函数作用域属于静态作用域，就是函数作用域的嵌套关系在函数定义时确定了，废话不多说直接上例子12345678910[javascript] view plain copyvar a='out a'; function test()&#123; console.log(a); // out a &#125; function outer()&#123; var a=\"in a\"; test() &#125;; outer(); ok，接下来就是箭头函数的this， 以下为我的理解，如有不正之处，望指点。 箭头函数不能用于构造函数，在上面的例子中，test1箭头函数定义在最外面，当test1函数打印this对象时会根据定义时决定的作用域嵌套关系逐级向上查找，因此查找的是window对象，在test2箭头函数中，由于test2定义在类P的func函数中，test2箭头函数打印this时，会先去func方法查找，找到了，然后打印。test3中，类中的方法默认开启了严格模式 所以test3中this为undefined。 可以将箭头函数中的this类比为函数中定义的变量，使用时按照定义时决定的作用域逐级查找直到找到为止。 原文地址","tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"toString()和valueOf()重写的区别","date":"2017-04-05T02:30:48.000Z","path":"2017/04/05/toString-和valueOf-重写的区别/","text":"基本上，所有JS数据类型都拥有valueOf和toString这两个方法，null除外。 看过朋友的笔试题，我觉得有必要记录一下这两者的区别，理解这两个方法对日后javascript值运算与显示的问题有很大帮助。答案：12345678910111213function add(x) &#123; var sum = x; var tmp = function (y) &#123; sum = sum + y; return tmp; &#125;; tmp.toString = function () &#123; return sum; &#125;; return tmp;&#125;console.log(add(1)(2)(3)); //6console.log(add(1)(2)(3)(4)); //10 Javascript中valueOf函数方法是返回指定对象的原始值。使用方法：object.valueOf( )object是必选项参数是任意固有 Jscript 对象。每个Javascript固有对象的 valueOf 方法定义不同。 对象 返回值 Array 数组的元素被转换为字符串，这些字符串由逗号分隔，连接在一起。其操作与 Array.toString 和 Array.join 方法相同。 Boolean Boolean 值。 Date 存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC。 Function 函数本身。 Number 数字值。 Object 对象本身。这是默认情况。 String 字符串值。 Math 和 Error 对象没有 valueOf 方法。 Javascript 的 toString() 方法 toString() 方法可把一个逻辑值转换为字符串，并返回结果。用法 booleanObject.toString()，返回值根据原始布尔值或者 booleanObject 对象的值返回字符串 “true” 或 “false”。如果调用该方法的对象不是 Boolean，则抛出异常 TypeError。 当这两者单独重写的时候不会出现问题，会根据他们重写后返回的类型进行输出对应的值，但当两者同时存在的时候，两者的区别就出来了123456789101112131415161718var bbb = &#123; i: 10, toString: function() &#123; console.log('toString'); return this.i; &#125;, valueOf: function() &#123; console.log('valueOf'); return this.i; &#125; &#125; alert(bbb);// 10 toString alert(+bbb); // 10 valueOf alert(''+bbb); // 10 valueOf alert(String(bbb)); // 10 toString alert(Number(bbb)); // 10 valueOf alert(bbb == '10'); // true valueOf alert(bbb === '10'); // false 如果转换为字符串时调用toString方法，如果是转换为数值时则调用valueOf方法，但其中有两个很不和谐。一个是alert(‘’+bbb)，字符串合拼应该是调用toString方法，但最终却调用valueOf方法。 结论如果只重写了toString，对象转换时会无视valueOf的存在来进行转换。但是，如果只重写了valueOf方法，在要转换为字符串的时候会优先考虑valueOf方法。在不能调用toString的情况下，只能让valueOf上阵了。对于那个奇怪的字符串拼接问题，可能是出于操作符上，翻开ECMA262-5 发现都有一个getValue操作。嗯，那么谜底应该是揭开了。重写会加大它们调用的优化高，而在有操作符的情况下，valueOf的优先级本来就比toString的高。 别人的答案分析 两者区别","tags":[{"name":"笔试","slug":"笔试","permalink":"http://yoursite.com/tags/笔试/"}]},{"title":"跨平台开发(rn版)","date":"2017-03-08T10:43:29.000Z","path":"2017/03/08/跨平台开发-rn版/","text":"【原生APP和混合开发与H5对比】1、前者有更合适的线程模型，尽管Web Worker可以解决一部分问题，但如图像解码、文本渲染仍无法多线程渲染，这影响了Web的流畅性。当大量用户访问H5应用时，或者要加载大图片资源时，效率降低，图片可能会出现失真的情况 2、原生APP拥有成熟的第三方库和组件，相比react native和H5更为有优势，react native的组件和库没有那么全，性能会比源生略差一点【虚拟DOM】1、组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）。 【DOM Diff算法】1、Web界面由DOM树来构成，当其中某一部分发生变化时，其实就是对应的某个DOM节点发生了变化。前后两个状态就对应两套界面，然后由React来比较两个界面的区别，这就需要对DOM树进行Diff算法分析。 2、它可以极大提高网页的性能表现 【react native语言环境JSX】（必须要引入babel的JSX解析器，把JSX转化成JS语法）JSX的特点： 1、类XML语法容易接受，结构清晰 2、增强JS语义 3、抽象程度高，屏蔽DOM操作，跨平台 4、代码模块化 【JSX注释注意点】1、在VIEW里面注释要用{} eg {/2222/} 【修改APP名字】1、 里面的info.plist修改 【APP是编译型运行，浏览器解析型运行】1、编译型语言：定义：指用专用的编译器，针对特定的操作平台（操作系统）将某种高级语言源代码一次性翻译成可被硬件平台直接运行的二进制机器码（具有操作数，指令、及相应的格式），这个过程叫做编译；编译好的可执行性文件（.exe），可在相对应的平台上运行（移植性差，但运行效率高）。 2、解析型语言：定义：指用专门解释器对源程序逐行解释成特定平台的机器码并立即执行的语言；相当于把编译型语言的编译链接过程混到一起同时完成的。解释型语言执行效率较低，且不能脱离解释器运行，但它的跨平台型比较容易，只需提供特定解释器即可。 【没有继承CSS样式概念】1、子元素里面没有继承父元素css一说 【getDefaultProps】（ES5函数）1、该函数用于初始化一些默认的属性 2、ES6中通过组件.defaultProps = {name: “abc”};（写在组件外面） 在上下文中直接 {this.props.name} 3、当不通过defaultProps定义默认值，在上下文直接调用this.props. 可以自定义组件，通过父级传值改变组件状态 【getInitialState】（ES5函数）1、 该函数是用于对组件的一些状态进行初始化 2、ES6中通过在组件中写 constructor(props){ super(props); //初始状态 == getInitialState函数 //数据驱动界面 this.state = { height: ‘60cm’; };} //在上下文通过this.state. 拿值， 通过this.setState({height: this.state.height ==3})改值，达到刷新页面效果 【React Native组件的生命周期】1、React Native组件的生命周期大致上可以划分为实例化阶段、存在阶段和销毁阶段，其中最常用的为实例化阶段，该阶段就是组件的构建、展示时期，需要我们根据几个函数的调用过程，控制好组件的展示和逻辑的处理。 2、getDefaultProps -&gt; getInitialState -&gt; componentWillMount -&gt; render -&gt; componentDidMount","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"react-native","slug":"react-native","permalink":"http://yoursite.com/tags/react-native/"}]},{"title":"SeaJs学习，解决了前端模块只会用ng的一些问题","date":"2017-01-25T02:30:48.000Z","path":"2017/01/25/SeaJs学习，解决了前端模块只会用ng的一些问题/","text":"为什么学习SeaJs ？【第一】：为了解决项目中资源文件版本号的问题，以及打包压缩合并等问题。 【第二】：好奇心和求知欲。【我发现很多知名网站也都在使用（ qq空间 , msn , 淘宝 等等），而且 SeaJs 也得到了很好的推广与应用】。 【第三】：经过了解得知 淘宝的 玉伯 是 湖南炎陵 人，觉得他很牛X。 【强烈】给小伙伴们推荐一个 玉伯 的讲的 SeaJs PDF 学习资料,下载地址： http://pan.baidu.com/s/1CCz4C 第一步 【 版本号问题的解决】 ：首先大家可以到 seaJs.org 官网去下载一个 seajs 的 例子，以及文件，现在 sea.js 的版本 已经到 V 2.1.1 了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head runat=\"server\"&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt; &lt;title&gt;SeaJsDemo-操作&lt;/title&gt; &lt;script src=\"script/src/sea.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div style=\"margin: 100px;\"&gt; &lt;!----------------------&gt; &lt;div id=\"idTest\" class=\"claTest1\"&gt;SeaJS-你也可以&lt;/div&gt; &lt;br /&gt; &lt;!----------------------&gt; &lt;div id=\"btnCLick\" class=\"claTest2\"&gt;Jquery-回调测试看看&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; seajs.config(&#123; // 别名配置 paths: &#123; \"urlSite\": \"http://gdboc.sell.uni2uni.com/\" //跨目录调用模块可以使用；获得当目录比较深时也可以使用 &#125;, // 别名配置 alias: &#123; 'jquery': 'jquery', 'style': '/style/a.css', \"styleUrl\": \"urlSite/style/style.css\" &#125;, preload: ['jquery'],//预先加载 base: '/script/src/', //基础路径 map: [[/^(.*\\.(?:css|js))(.*)$/i, '$1?v=20131010']], //map,批量更新时间戳 charset: 'utf-8' // 文件编码 &#125;); //-------seajs.use为入口模块，也可以用 data-main=\"\";(区别在于use可以加载多个入口函数，以及做一些回调的操作)------------ seajs.use(['init', 'jquery'], function (i, $) &#123; alert(\"亲，全部加载都完成了!\"); //----------调用init中对外公开的接口-------------------------------- i.alertFun(); //----------习惯了在页面&lt;script&gt;写$就可以了------------------- $(function () &#123; $(\"#btnCLick\").click(function () &#123; alert(\"jquery被模块化了,我不太习惯了！\"); &#125;) &#125;) &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; View Code SeaJs里，你必须知道那些东西 ：【 1】. define define 是一个全局函数，用来定义模块【每一个js文件都是一个小模块】 define(function( require , exports , module ){ // require: 是一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口 // exports: 是一个对象，用来向外提供模块接口 // module: 是一个对象，上面存储了与当前模块相关联的一些属性和方法 }) init.js 文件源码 ：12345678910111213141516//--------------------------------------------define(function (require, exports, module) &#123; require('test'); require('style'); //----对外提供公共的接口------ exports.alertFun = function () &#123; //...................... alert(\"init中对外提供的接口被调用了！\"); &#125;; //----暴露到全局------------- //module.exports = function () &#123; // //...................... //&#125;;&#125;); 【 2】.seajs.config 配置一些全局的东西， 版本问题可以在这里解决 详细说明如下：123456789101112131415161718&lt;script type=\"text/javascript\"&gt; seajs.config(&#123; // 路径配置 paths: &#123; \"urlSite\": \"http://gdboc.sell.uni2uni.com/\" //跨目录调用模块可以使用；获得当目录比较深时也可以使用 &#125;, // 别名配置 alias: &#123; 'jquery': 'jquery', 'style': '/style/a.css', \"styleUrl\": \"urlSite/style/style.css\" &#125;, preload: ['jquery'],//预先加载 base: '/script/src/', //基础路径 map: [[/^(.*\\.(?:css|js))(.*)$/i, '$1?v=20131010']], //map,批量更新时间戳 charset: 'utf-8' // 文件编码 &#125;); &lt;/script&gt; 【3】.seajs.use seajs.use 为 seajs 的入口模块。还可以直接写成这样： seajs.use (“ init.js “) 和 data-mian =” init.js “ 的区别在于 seajs.use 可以加载多个入口函数，以及做一些回调的操作1234567891011121314script type=\"text/javascript\"&gt; //-------seajs.use为入口模块，也可以用 data-main=\"\";(区别在于use可以加载多个入口函数，以及做一些回调的操作)------------ seajs.use(['init', 'jquery'], function (i, $) &#123; alert(\"亲，全部加载都完成了!\"); //----------调用init中对外公开的接口-------------------------------- i.alertFun(); //----------习惯了在页面&lt;script&gt;写$就可以了------------------- $(function () &#123; $(\"#btnCLick\").click(function () &#123; alert(\"jquery被模块化了,我不太习惯了！\"); &#125;) &#125;) &#125;); &lt;/script&gt; 【4】. 不要以为 SeaJs 真就我讲的这么点东西了，我还没有很 深入细化 的讲，拿了几个我认为最重要的，故 省略…………","tags":[{"name":"seajs","slug":"seajs","permalink":"http://yoursite.com/tags/seajs/"}]},{"title":"彻底理解原型链 (prototype chain)和Simple JavaScript Inheritance","date":"2016-11-22T10:43:29.000Z","path":"2016/11/22/彻底理解原型链-prototype-chain-和Simple-JavaScript-Inheritance/","text":"彻底理解原型链 (prototype chain)在 ECMAScript 中，每个由构造器创建的对象拥有一个指向构造器 prototype 属性值的 隐式引用（implicit reference），这个引用称之为 原型（prototype）。进一步，每个原型可以拥有指向自己原型的 隐式引用（即该原型的原型），如此下去，这就是所谓的 原型链（prototype chain） （参考资源）。在具体的语言实现中，每个对象都有一个 proto 属性来实现对原型的 隐式引用。程序清单 4说明了这一点。 清单 4. 对象的 proto 属性和隐式引用123456789function Person( name ) &#123; this.name = name; &#125;var p = new Person();//对象的隐式引用指向了构造器的 prototype 属性，所以此处打印 trueconsole.log( p.__proto__ === Person.prototype );//原型本身是一个 Object 对象，所以他的隐式引用指向了// Object 构造器的 prototype 属性 , 故而打印 trueconsole.log(Person.prototype.__proto__ === Object.prototype );// 构造器 Person 本身是一个函数对象，所以此处打印 trueconsole.log( Person.__proto__ === Function.prototype ); 有了 原型链，便可以定义一种所谓的 属性隐藏机制，并通过这种机制实现继承。ECMAScript 规定，当要给某个对象的属性赋值时，解释器会查找该对象原型链中第一个含有该属性的对象（注：原型本身就是一个对象，那么原型链即为一组对象的链。对象的原型链中的第一个对象是该对象本身）进行赋值。反之，如果要获取某个对象属性的值，解释器自然是返回该对象原型链中首先具有该属性的对象属性值。图 1说名了这中隐藏机制： 图 1. 原型链中的属性隐藏机制 在图 1 中，object1-&gt;prototype1-&gt;prototype2 构成了 对象 object1 的原型链，根据上述属性隐藏机制，可以清楚地看到 prototype1 对象中的 property4 属性和 prototype2 对象中的 property3 属性皆被隐藏。理解了原型链，那么将非常容易理解 JS 中基于原型的继承实现原理，程序清单 5 是利用原型链实现继承的简单例子。 清单 5. 利用原型链 Horse-&gt;Mammal-&gt;Animal 实现继承123456789101112131415161718192021222324252627282930313233// 声明 Animal 对象构造器function Animal() &#123; &#125;// 将 Animal 的 prototype 属性指向一个对象，// 亦可直接理解为指定 Animal 对象的原型Animal.prototype = &#123; name: \"animal\", weight: 0, eat: function() &#123; alert( \"Animal is eating!\" ); &#125;&#125;// 声明 Mammal 对象构造器function Mammal() &#123; this.name = \"mammal\"; &#125;// 指定 Mammal 对象的原型为一个 Animal 对象。// 实际上此处便是在创建 Mammal 对象和Animal 对象之间的原型链Mammal.prototype = new Animal();// 声明 Horse 对象构造器function Horse(height,weight)&#123; this.name = \"horse\"; this.height = height; this.weight = weight;&#125;// 将 Horse对象的原型指定为一个 Mamal 对象，继续构建 Horse 与 Mammal 之间的原型链Horse.prototype = new Mammal();// 重新指定 eat方法 , 此方法将覆盖从 Animal 原型继承过来的 eat 方法Horse.prototype.eat = function() &#123; alert( \"Horse is eating grass!\" );&#125;// 验证并理解原型链var horse = new Horse( 100, 300 );console.log(horse.__proto__ === Horse.prototype);console.log( Horse.prototype.__proto__ === Mammal.prototype );console.log( Mammal.prototype.__proto__ === Animal.prototype ); 理解清单 5 中对象原型继承逻辑实现的关键在于 Horse.prototype = new Mammal() 和 Mammal.prototype = new Animal() 这两句代码。首先，等式右边的结果是构造出一个临时对象，然后将这个对象赋值给等式左边对象的 prototype 属性。也就是说将右边新建的对象作为左边对象的原型。读者可以将这两个等式替换到相应的程序清单 5 代码最后两行的等式中自行领悟。 JavaScript 类式继承的实现方法从代码清单 5 可以看出，基于原型的继承方式，虽然实现了代码复用，但其行文松散且不够流畅，可阅读性差，不利于实现扩展和对源代码进行有效地组织管理。不得不承认，类式继承方式在语言实现上更具健壮性，且在构建可复用代码和组织架构程序方面具有明显的优势。这使得程序员们希望寻找到一种能够在 JavaScript 中以类式继承风格进行编码的方法途径。从抽象的角度来讲，既然类式继承和原型继承都是为实现面向对象而设计的，并且他们各自实现的载体语言在计算能力上是等价的 ( 因为图灵机的计算能力与 Lambda 演算的计算能力是等价的 )，那么能不能找到一种变换，使得原型式继承语言通过该变换实现具有类式继承编码的风格呢？ 目前一些主流的 JS 框架都提供了这种转换机制，也即类式声明方法，比如 Dojo.declare()、Ext.entend() 等等。用户使用这些框架，可以轻易而友好地组织自己的 JS 代码。其实，在众多框架出现之前，JavaScript 大师 Douglas Crockford 最早利用三个函数对 Function 对象进行扩展，实现了这种变换，关于它的实现细节可以（参考资源）。此外还有由 Dean Edwards实现的著名的 Base.js（参考资源）。值得一提的是，jQuery 之父 John Resig 在搏众家之长之后，用不到 30 行代码便实现了自己的 Simple Inheritance。使用其提供的 extend 方法声明类非常简单。程序清单 6是使用了 Simple Inheritance库实现类的声明的例子。其中最后一句打印输出语句是对 Simple Inheritance实现类式继承的最好说明。 清单 6. 使用 Simple Inheritance 实现类式继承1234567891011121314151617181920212223242526// 声明 Person 类var Person = Class.extend( &#123; _issleeping: true, init: function( name ) &#123; this._name = name; &#125;, isSleeping: function() &#123; return this._issleeping; &#125;&#125; ); // 声明 Programmer 类，并继承 Personvar Programmer = Person.extend( &#123; init: function( name, issleeping ) &#123; // 调用父类构造函数 this._super( name ); // 设置自己的状态 this._issleeping = issleeping; &#125;&#125; );var person = new Person( \"张三\" );var diors = new Programmer( \"张江男\", false );// 打印 trueconsole.log( person.isSleeping() );// 打印 falseconsole.log( diors.isSleeping() );// 此处全为 true，故打印 trueconsole.log( person instanceof Person &amp;&amp; person instanceof Class &amp;&amp; diors instanceof Programmer &amp;&amp;diors instanceof Person &amp;&amp; diors instanceof Class ); 如果您已对原型、函数构造器、闭包和基于上下文的 this 有了充分的理解，那么理解 Simple Inheritance 的实现原理也并非相当困难。从本质上讲，var Person = Class.extend(…)该语句中，左边的 Person 实际上是获得了由 Class 调用 extend 方法返回的一个构造器，也即一个 function 对象的引用。顺着这个思路，我们继续介绍 Simple Inheritance 是如何做到这一点，进而实现了由原型继承方式到类式继承方式的转换的。图 2是 Simple Inheritance 的源码及其附带注释。为了方便理解，用中文对代码逐行补充说明。 图 2.Simple Inheritance 源码解析 抛开代码第二部分，整体连贯地考察第一和第三部分会发现，extend 函数的根本目的就是要构造一个具有新原型属性的新构造器。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"ajax加载进去的内容绑定事件不生效","date":"2016-11-22T10:43:29.000Z","path":"2016/11/22/ajax加载进去的内容绑定事件不生效/","text":"遇到的问题：在对象中的top方法中绑定一个click事件,但无法绑定成功。 误区：认真查看，发现只有在请求ajax的时候，这个top方法才不能正常绑定事件，当时候觉得是因为还未动态生成出来就进行绑定a事件，所以绑定不成功，但查了资料dom树是实时更新的，所以跟顺序没有关系。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465(function()&#123; // 评论条对象 // 属性：内容 // 方法：点赞，踩，删除 window.Comment = function (json)&#123; this.content = json.content || \"\"; this.acc = json.acc || 0; this.ref = json.ref || 0; this.id = json.id; // this.top(); this.cut(); this.down_icon(); &#125;; Comment.prototype = &#123; constructor: Comment, render: function()&#123; var newCom = document.createElement(\"div\"); newCom.className = \"reply\"; var str = \"\"; str += '&lt;p class=\"replyContent\"&gt;'+ this.content +'&lt;/p&gt;'; str += '&lt;p class=\"operation\"&gt;'; str += '&lt;span class=\"replyTime\"&gt;2011-09-08 16:37:60&lt;/span&gt;'; str += '&lt;span class=\"handle\"&gt;'; str += '&lt;a href=\"javascript:;\" class=\"top\"&gt;'+this.acc+'&lt;/a&gt;'; str += '&lt;a href=\"javascript:;\" class=\"down_icon\"&gt;0&lt;/a&gt;'; str += '&lt;a href=\"javascript:;\" class=\"cut\"&gt;删除&lt;/a&gt;'; str += '&lt;/span&gt;'; str += '&lt;/p&gt;'; newCom.innerHTML = str; return newCom; &#125;, cut: function()&#123; &#125;, top: function()&#123; var top1 = this.render().getElementsByTagName(\"a\")[0]; var self = this; top1.addEventListener(\"click\", function()&#123; console.log(1); ajax(&#123; url: \"weibo.php\", data: &#123; \"act\": \"acc\", \"id\": self.id &#125;, success: function(str)&#123; var json = eval(\"(\"+ str +\")\") if(json.error == 0)&#123; self.acc += 1; console.log(1); &#125; &#125; &#125;); &#125;); &#125;, down_icon: function()&#123;&#125; &#125;;&#125;)(); 误区2：后来我想到难道是延时的问题吗？ajax请求和绑定事件都有延时操作，所以直接把top方法传递一个参数接收外面传进来的函数，这个函数去做绑定操作。123456var fn1 = function()&#123; var ms = document.getElementsByClassName(\"top\")[0]; ms.addEventListener(\"click\", function()&#123; console.log(1); &#125;);&#125; 1234top: function(fn)&#123; var top1 = this.render().getElementsByTagName(\"a\")[0]; fn();&#125; 就这样竟然达到我想要的绑定效果。。。。。。其实不知道我这样想有没有道理但 结论：通过ajax加载进来的js默认是不会执行的，同样通过ajax加载进来的dom元素默认也是没有事件的; 如果要给通过ajax加载进来的dom元素绑定事件,1、使用delegate(JQ方法)，在初始化页面时，将事件绑定到已经存在的页面元素中","tags":[{"name":"ajax","slug":"ajax","permalink":"http://yoursite.com/tags/ajax/"}]},{"title":"原型链的个人分析","date":"2016-11-22T10:43:29.000Z","path":"2016/11/22/原型链的个人分析/","text":"首先此文对有一定原型链认识的人来说比较能理解。为什么研究这个如此麻烦的原型链，我是被两道原型链的题目考到了，据说是8级的JS笔试题。1234567var a = &#123;&#125;, b = Object.prototype;console.log([a.prototype === b, Object.getPrototypeOf(a) === b]);//A [false true]//B [false false]//C [true true]//D [true false] 1234567function f() &#123;&#125;var a = f.prototype; //f的原型对象var b = Object.getPrototypeOf(f); //Function的原型对象console.log(a === b); //true or falseconsole.log(a,b);console.log((b == f)); //函数是对象,是引用类型的 答案自己想，显然第一题跟我下面说的完整原型链没有太大关系，我也是突然想到要重新整理一份而已。 其次为了显然易懂自己画了幅图（图1） 图1中右边的虚线框就是我们正常的原型链继承方式，这个没有任何问题，蓝色虚线框就是对一个构造函数是谁创建出来的实例进行探索。这里每一个构造函数或者实例或者原型对象都有一个创建它本身的构造函数Function,能通过图看懂到这里，那么我总结一下我发现的原型链的关系 这里得出结论： 构造函数的本质就是一个对象，构造函数的constructor一定是指向Function –&gt; function Function(){}; 构造函数的隐式原型一定是指向空函数 –&gt; function (){}; 粉红色的方形最终的隐式原型都是指向空的函数–&gt;Object(){}, 那么我们可以理解(空的函数) == (空的对象)，但注意这样在浏览器中打印却是false。 如果是实例但又不是构造函数，那么它没有原型对象–&gt;实例没有原型对象 每一个构造函数都有一个像上面蓝色虚线框的指向,这样也检验了第三条(空的函数) == (空的对象)的说法。 最后当面试官问题为什么 (Function instanceof Object) (Object instanceof Function) (Function instanceof Function) (Object instanceof Object)的时候你就跟他说出这样的结论，估计在糟糕的面试过程中还能挽回一些面子。 原型链文字解释 — Function是一个构造函数,因此有一个和他相关联的原型对象 Function.prototype == function () {} Object也是一个构造函数,因此也有一个原型对象 Object.prototype == Object {} — Function本质上也是一个对象,因此它也有构造函数.Function.constructor == function Function() { [native code] } 也有自己的原型对象:Function.proto == function () {} Function.proto == Function.prototype (空的函数) = (空的函数)— Object本质上也是一个对象,因此它也有构造函数,Object.constructor == function Function() { [native code] } — Function.prototype == 空的函数空的函数也是一个对象,它也有构造函数:Function.prototype.constructor == function Function() { [native code] }也有原型对象:Function.prototype.proto == Object {} == &gt;Object.prototypeFunction.prototype.constructor.prototype == Function.prototype.proto(function () {}) == (Object {}) //可以认为== — Function既可以实例化Object对象也可以实例化Function对象 — Function 和Object之间的关系 — Function的原型对象是一个空的函数,这个空函数的原型对象是Object.prototype","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"使用angular做微信内html5开发时碰到的两个坑","date":"2016-06-28T10:43:29.000Z","path":"2016/06/28/使用angular做微信内html5开发时碰到的两个坑/","text":"1、微信支付授权的url在SPA内不会正确改变。 简单的说就是有页面A、B、C，C为支付页面，当从A进入SPA时，以A&gt;B&gt;C的顺序在页面C调用微信js接口支付，提示地址未授权而且url竟然是A的；以B&gt;C的顺序，在页面C取到的url是B的，最恶心的是该情况只会出现在ios系统的微信内，安卓的SPA拿到的url是正确的。当时想到的解决方案就是在angular入口的地址后紧跟?，然后调用微信js支付时微信会认为?后均为页面参数，不会对授权的url有影响。2、微信初始化时请求了两次地址，导致微信跳转到缺省的angular路由。 具体表现为我的angular入口为index，然后有路由index#/detail/1，在访问时由于地址为index#/detail/1，浏览器会直接访问index然后由angular来处理#/detail/1，然后index需要微信授权，就导致了授权后跳转到index然后angular跳转到了缺省的路由。解决方法很简单。。。去掉url内的#即可，去掉后的实现相当于将index/路径下的所有请求都使用sendfile的方法将angular的index内的内容当作模板进行应答，然后由angular根据index内的base href来获取原应在#后的内容进行路由处理，其实实现的方式是一样的，只不过一个是由服务器将所有angular处理的请求都返回了index，另一个是由浏览器将所有angular的请求都定向到index。 #去掉后问题1也不用加?即可解决了，打开angular相关实现的代码看了看，还是很巧妙的。","tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"},{"name":"微信","slug":"微信","permalink":"http://yoursite.com/tags/微信/"}]},{"title":"bash命令和vi编辑器命令汇总","date":"2015-11-02T00:43:29.000Z","path":"2015/11/02/bash命令和vi编辑器命令汇总/","text":"bash命令（Linux 默认使用 bash，Git内置了bash） 常见命令格式：命令 [-options] [参数]1、pwd (Print Working Directory) 查看当前目录2、cd (Change Directory) 切换目录，如 cd /etc3、ls (List) 查看当前目录下内容，如 ls -al4、mkdir (Make Directory) 创建目录，如 mkdir blog5、touch 创建文件，如 touch index.html6、wc (Word Count) 字数信息统计，如 wc index.html7、cat 查看文件全部内容，如 cat index.html8、more less 查看文件，如more /etc/passwd、less /etc/passwd9、rm (remove) 删除文件，如 rm index.html、rm -rf blog10、rmdir (Remove Directory) 删除文件夹，只能删除空文件夹，不常用 11、mv (move) 移动文件或重命名，如 mv index.html ./demo/index.html12、cp (copy) 复制文件，cp index.html ./demo/index.html13、head 查看文件前几行，如 head -5 index.html14、tail 查看文件后几行 –n –f，如 tail index.html、tail -5 index.html15、tab 自动补全，连按两次会将所有匹配内容显示出来16、history 查看操作历史17、ssh 远程登录，如ssh root@gitlab.study.com18、&gt; 和 &gt;&gt;重定向，如echo hello world! &gt; README.md，&gt;覆盖 &gt;&gt;追加（把本该输出到控制台上的信息存储在README.md）19、wget 下载，如wget https://nodejs.org/dist/v4.4.0/node-v4.4.0.tar.gz20、tar 解压缩，如tar zxvf node-v4.4.0.tar.gz 21、echo 类似print在控制台输出代码段 Vi编辑器三种模式 命令行模式命令ZZ（大写）保存并退出 u辙销操作，可多次使用 dd删除当前行 yy复制当前行 p 粘贴内容 ctrl+f向前翻页 ctrl+b向后翻页 i进入编辑模式，当前光标处插入 a进入编辑模式，当前光标后插入 A进入编辑模式，光标移动到行尾 o进入编辑模式，当前行下面插入新行 O进入编辑模式，当前行上面插入新行 底行模式命令:w保存，:w filenme另存为:q退出:wq保存并退出:e! 撤销更改，返回到上一次保存的状态:q! 不保存强制退出:set nu 设置行号","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"常用 Git 命令清单","date":"2015-11-02T00:43:29.000Z","path":"2015/11/02/常用-Git-命令清单/","text":"我每天使用 Git ，但是很多命令记不住。一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。1234Workspace：工作区Index / Stage：暂存区Repository：仓库区（或本地仓库）Remote：远程仓库 一、新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 二、配置123456789101112Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 三、增加/删除文件 123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 四、代码提交 123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 五、分支 123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 六、标签 1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 七、查看信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 八、远程同步 1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 九、撤销 12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 十、其他 12# 生成一个可供发布的压缩包$ git archive 十一、其他2 12345# 生成一个本地的公共仓库（局域网内共享仓库）$ git clone --bare [被赋值的文件] [共享仓库名字.git]# 复制仓库并创建名字$ git clone [被赋值文件夹名字] [新建文件夹名字] 解决冲突把HEAD ==== CONFICT 这3个注释删掉就可以原文地址","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"js访问CSS的2种方法（点法和中括号法的区别），内含获取属性的兼容写法","date":"2015-10-15T00:43:29.000Z","path":"2015/10/15/js访问CSS的2种方法（点法和中括号法的区别），内含获取属性的兼容写法/","text":"1.1 js 常用 访问 CSS 属性 我们访问得到css 属性，比较常用的有两种： 利用点语法box.style.widthbox.style.top 点语法可以得到 width 属性 和 top属性 带有单位的。 100px 但是这个语法有非常大的缺陷， 不变的。 后面的width 和 top 没有办法传递参数的。 12var w = width;box.style.w 利用 [] 访问属性 语法格式: box.style[“width”] 元素.style[“属性”]; console.log(box.style[&quot;left&quot;]); 最大的优点 ： 可以给属性传递参数 1.2 得到css 样式 我们想要获得css 的样式， box.style.left box.style.backgorundColor 但是它只能得到 行内的样式。 但是我们工作最多用的是 内嵌式 或者 外链式 。 怎么办？ 核心： 我们怎么才能得到内嵌或者外链的样式呢？ obj.currentStyle ie opera 常用 外部（使用&lt;link&gt;）和内嵌（使用&lt;style&gt;）样式表中的样式（ie和opera） 2 .window.getComputedStyle(&quot;元素&quot;, &quot;伪类&quot;) w3c 两个选项是必须的， 没有伪类 用 null 替代 3 兼容写法 ： 我们这个元素里面的属性很多， left top width===我们想要某个属性， 就应该 返回改属性，所有继续封装 返回当前样式的 函数。12345678910111213141516171819202122var demo = document.getElementById(\"demo\"); function getStyle(obj,attr) &#123; // 谁的 那个属性 if(obj.currentStyle) // ie 等 &#123; return obj.currentStyle[attr]; &#125; else &#123; return window.getComputedStyle(obj,null)[attr]; // w3c 浏览器 &#125; &#125; console.log(getStyle(demo,\"width\"));","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"JS中实际上有六种数据类型（解释NULL和Object的关系）","date":"2015-10-15T00:43:29.000Z","path":"2015/10/15/JS中实际上有六种数据类型（解释NULL和Object的关系）/","text":"JavaScript中包含6种数据类型：undefined、null、string、number、boolean和object。其中，前5 种是原始数据类型，object是对象类型。 object类型中包括Object、Function、String、Number、Boolean、Array、Regexp、Date、 Globel、Math、Error，以及宿主环境提供的object类型。 Null类型是第二个只有一个值的数据类型，这个特殊的值是null，从逻辑角度来看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null值会返回“object”的原因，如下面的例子所示： 12var car =null;alert(typeof null); //object（&lt;font color=red&gt;其实这是JavaScript最初实现的一个错误，后来被ECMAScript沿用下来&lt;/font&gt;） 如果定义的变量准备在将来用户保存对象，那么最好将该变量初始化为null而不是其他值。这样一来，只要直接检查null值就可以知道相应的变量是否已经保存了一个对象的引用，如下面的例子：12345if(car != null)&#123;//对car执行某些操作&#125; 原文地址","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"setInterval的返回值类型为什么为数值?","date":"2015-10-15T00:43:29.000Z","path":"2015/10/15/setInterval的返回值类型为什么为数值/","text":"1234567btn[0].onclick = function()&#123; var timer = null; timer = setInterval(function()&#123; console.log('a'); &#125;,1000) console.log(typeof timer); //返回的是一个number数据类型&#125; DOM事件必须用绑定时所使用的同一个函数才能解绑。这是因为DOM事件不是由JavaScript来触发的，而是浏览器触发的。不管你绑定不绑定处理函数，也不管你绑定多少个事件处理函数，事件就在那里，只要用户点击了元素，click事件就会触发。所以你不再需要对这个事件进行处理的时候，只需解绑相应的函数即可。而定时器事件不一样，它是JavaScript设定的，你可以在一个网页中设定多个定时器，因此你需要一个独一无二的东西来代表特定的定时器。但你无法取消对定时器事件的绑定，只能关闭这个定时器（其实完全可以把定时器事件设定成跟DOM事件一样的风格，先设置一个定时器，然后可以随时给这个定时器绑定、解绑处理函数而不是直接关闭处理器。之所以没有这样设计，应该是历史原因吧哈哈）。 定时器在JavaScript语言中并没有相应的类型，因此我们只能获得一个与定时器有关的数据，这样才能使用系统提供的函数来启动和关闭它。这个数据可以是一个string，一个number，甚至是一个array什么的都无所谓，但是最简单有效的方式就是用一个number了。 segmentfault也是一个中国开发者技术社区，感觉很厉害的样子 作者：陈安链接：https://www.zhihu.com/question/31932536/answer/53917339来源：知乎著作权归作者所有，转载请联系作者获得授权。 原文地址","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"少见问题","date":"2015-08-03T05:43:29.000Z","path":"2015/08/03/少见问题/","text":"【button的宽高跟别的行内块元素有区别】1、&lt;input type=&quot;buttom&quot;&gt;&lt;/input&gt; 和&lt;button&gt;&lt;/button&gt; button属性的元素会自带类似box-sizing:border-box属性；如果设置固定宽度在外加padding值，宽高=padding值+内容宽高【js中不通过getElementById获取ID或者标签】1、js中不通过getElementById获取ID或者标签也可以在页面中直接调用dom元素节点定义的id值 eg12// var id = document.getElementById('id');console.log(id); 最终结果也是输出指向该id的dom节点，原因是JS是在浏览器解析的而且JS是弱的编程语言，所以可以写得比较随意 【小盒子绝对定位设置高度100%就是视口（一屏）的高度】1、小盒子的层层父级都没有定位，那么当小盒子绝对定位后并设置高度100%，那么小盒子实际高度为视口的高度（相当于body.clientHeight的高度） 当父级有定位的时候，子盒子的高度百分比一定是根据父级基数计算 eg:12345678910html,body &#123; width: 100%; height: 100px;&#125;.wrap &#123; width: 400px; height: 100%; background-color: pink; position: absolute; //实际高度为视口的高度并不是body的100px&#125; 【函数里变量名与形参冲突】1、当函数里变量名与形参冲突，按顺序由上到下检查，最后输出会是变量的值eg:12345678910111213141516171819202122(function an(a)&#123; console.log(a); // 1 var c = a; var a = 4; var b = a; console.log(c); // 1 console.log(b); // 4&#125;)('1')``` 【电脑的运行所谓多线程操作原理】1、实际上当电脑同时打开游戏，音乐，电影，计算机是通过调频操作完成同时打开程序，也就是还是单线程，但为什么可以同时运作，就是调频操作就是游戏运行0.0几毫秒，音乐用下一个0.0几毫秒，电影用下一个0.0几毫秒，不断的跳，在普通用户看就感觉是同时打开，但其实并不是多线程【面试】```javascriptfunction show()&#123; alert(1);&#125; alert(show()); // 1 ----&gt; undefine (因为show函数没有返回值) (function(){}()); 和 (function(){})() 一样理解 ()里面的东西都是封闭的 【网页上富文本编辑器】（能在网页任何地方编写东西）1、在控制台上 输入document.body.contentEditable = true 【this】只要有闭包事件，它的调用者就是window,this就指向window，没有任何特殊情况 【块级元素里面的“行内块”元素的背景图不垂直居中显示】 1、正常情况有（行高）的块级元素里面包着行内块元素，行内块元素有背景图，背景图会垂直居中显示但如果行内块元素里面也有文字，那么背景图就不会垂直居中显示，而是向上显示，原因是文字的存在，导致背景被挤走解决办法在行内块元素内在重新定义行高等于行内块元素的高度 【script作为模板】1、&lt;script type=&quot;text/template&quot; id=&quot;demo&quot;&gt; 给 script 设置type= text/template ,标签里面的内容不会被执行,也不会显示在页面上,但是可以在另一个script里面通过获取","tags":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/tags/其他/"}]},{"title":"浏览器渲染HTML过程（页面重构师的存在所在原因）","date":"2015-08-03T04:43:29.000Z","path":"2015/08/03/浏览器渲染HTML过程（页面重构师的存在所在原因）/","text":"WEB 页面运行在各种各样的浏览器当中，浏览器载入、渲染页面的速度直接影响着用户体验简单地说，页面渲染就是浏览器将 HTML 代码根据 CSS 定义的规则显示在浏览器窗口中的这个过程。渲染过程 用户输入网址（假设是个 HTML 页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回 HTML 文件； 浏览器开始载入 HTML 代码，发现 &lt;head&gt; 标签内有一个 &lt;link&gt; 标签引用外部 CSS 文件； 浏览器又发出 CSS 文件的请求，服务器返回这个 CSS 文件； 浏览器继续载入 HTML 中 &lt;body&gt; 部分的代码，并且 CSS 文件已经拿到手了，可以开始渲染页面了； 浏览器在代码中发现一个 &lt;img&gt; 标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码； 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码； 浏览器发现了一个包含一行 JavaScript 代码的 &lt;script&gt; 标签，赶快运行它； JavaScript 脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个 &lt;div&gt;（style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码； 终于等到了 &lt;/html&gt; 的到来，浏览器泪流满面…… 等等，还没完，用户点了一下界面中的“换肤”按钮，JavaScript 让浏览器换了一下 标签的 CSS 路径； 浏览器召集了在座的各位 &lt;div&gt;&lt;span&gt;&lt;ul&gt;&lt;li&gt; 们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。 浏览器每天就这么来来回回跑着，要知道不同的人写出来的 HTML 和 CSS 代码质量参差不齐，说不定哪天跑着跑着就挂掉了。好在这个世界还有这么一群人——页面重构工程师，平时挺不起眼，也就帮视觉设计师们切切图啊改改字，其实背地里还是干了不少实事的。 reflow（回流） 说到页面为什么会慢？那是因为浏览器要花时间、花精力去渲染，尤其是当它发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，内行称这个回退的过程叫 reflow（回流，相关链接：reflow（回流））。 reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的 变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。 当 然，reflow 问题是可以优化的，我们可以尽量减少不必要的 reflow。比如开头的例子中的 &lt;img&gt;图片载入问题，这其实就是一个可以避免的 reflow —— 给图片设置宽度和高度就可以了。这样浏览器就知道了图片的占位面积，在载入图片前就预留好了位置。 原文地址","tags":[{"name":"HTML，面试","slug":"HTML，面试","permalink":"http://yoursite.com/tags/HTML，面试/"}]},{"title":"href和src有什么区别","date":"2015-08-03T04:43:29.000Z","path":"2015/08/03/href和src有什么区别/","text":"href和src是有区别的，而且是不能相互替换的。我们在可替换的元素上使用src，然而把href用于在涉及的文档和外部资源之间建立一个关系。href (Hypertext Reference)指定网络资源的位置，从而在当前元素或者当前文档和由当前属性定义的需要的锚点或资源之间定义一个链接或者���系。当我们写下： &lt;link href=”app.css” rel=”stylesheet” /&gt; 浏览器明白当前资源是一个样式表，页面解析不会暂停（由于浏览器需要样式规则去画或者渲染页面，渲染过程可能会被被暂停）。这与把css文件内容写在标签里不相同，因此建议使用link标签而不是@import来吧样式表导入到html文档里。 src (Source)属性仅仅 嵌入当前资源到当前文档元素定义的位置。当浏览器找到： &lt;script src=”app.js”&gt;&lt;/script&gt; 在浏览器下载，编译，执行这个文件之前页面的加载和处理会被暂停。这个过程与把js文件放到标签里类似。这也是建议把JS文件放到底部加载的原因。当然，img标签页与此类似。浏览器暂停加载直到提取和加载图像。 原文地址","tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"关于JS操作DOM的关系图","date":"2015-08-03T04:43:29.000Z","path":"2015/08/03/关于JS操作DOM的关系图/","text":"基础操作：兼容性（持续更新）: 数组及字符串的操作:","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"【外边距塌陷】【设置浮动都会变成行内块级元素】【行内元素本身能设置内外边距】","date":"2015-08-03T04:43:29.000Z","path":"2015/08/03/【外边距塌陷】【设置浮动都会变成行内块级元素】【行内元素本身能设置内外边距】/","text":"1、两个同级元素，垂直排列，上面的盒子给margin-bottom，同时下面的盒子给margin-top,那么他们两个盒子的外边距就会重叠，以最大的那个值进行计算；2、两个父子元素，内部的盒子给margin-top，然后其父级也会受到影响，同时产生上边距,不会得到想要结果， 解决的办法1、在父级元素上添加overflow:hidden; 左右外边距不受影响 2、给父元素设置透明边框 块级元素和行内元素只要设置float，都会变成行内块级元素属性 行内元素及行内块级元素要在页面居中，需要在外层套块级元素 行内元素本身能设置内外边距","tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"标签换行产生的间距消除的三种办法及子元素继承属性问题","date":"2015-08-03T04:43:29.000Z","path":"2015/08/03/标签换行产生的间距消除的三种办法及子元素继承属性问题/","text":"消除标签间距办法 1、在父盒子设置font-size:0;自身盒子设置原来字体大小； 2、float:left; 3、直接写成一行。 子元素仅继承盒子内的文字内容属性 eg:font-size; color 、font-family …. a标签不继承","tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"关于CSS通配符*问题（危害）及重置写法","date":"2015-08-03T04:43:29.000Z","path":"2015/08/03/关于CSS通配符-问题（危害）及重置写法/","text":"关于CSS通配符问题 A:不知道为什么css没有哦找到 用css 通配符“”的案例呢？ Q:一般用来消除浏览器默认属性 在大多数时 候，我们需要重置浏览器元素，在dushuwu.net中介绍过很多相关的知识，但尽可能少使用全局Reset，因为不同浏览器元素的默认属性有所 不同，使用Reset可重置浏览器元素的一些默认属性，以达到浏览器的兼容。但需要注意的是，请不要使用全局Reset：*{ margin:0; padding:0; }这不仅仅因为它是缓慢和低效率的方法，而且还会导致一些不必要的元素也重置了外边距和内边距。Reset并不是一成不变的，具体还需要根据项目的不同需求做适当的修改，以达到浏览器的兼容和操作上的便利性。52CSS建议使用的Reset如下:一、清除内外边距1234567891011body, h1, h2, h3, h4, h5, h6, hr, p,blockquote, /* structural elements 结构元素 */dl, dt, dd, ul, ol, li, /* list elements 列表元素 */pre, /* text formatting elements 文本格式元素 */form, fieldset, legend, button, input, textarea, /* form elements 表单元素 */th, td, /* table elements 表格元素 */img/* img elements 图片元素 52CSS.com */&#123; border:medium none; margin: 0; padding: 0;&#125; 二、设置默认字体body,button, input, select, textarea { font: 12px/1.5 ‘宋体’,tahoma, Srial, helvetica, sans-serif;} h1, h2, h3, h4, h5, h6 { font-size: 100%; } em{font-style:normal;}三、重置列表元素 ul, ol { list-style: none; }四、重置超链接元素a { text-decoration: none; color:#333;}a:hover { text-decoration: underline; color:#F40; }五、重置图片元素img{ border:0px; vertical-align:middle;} （消除图片3px间距方法）六、重置表格元素table { border-collapse: collapse; border-spacing: 0; }","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"在sublime中，css设置snippet后缀源要写.less才生效(内附50个css代码段链接)","date":"2015-08-03T01:43:10.000Z","path":"2015/08/03/在sublime中，css设置snippet后缀源要写-less才生效-内附50个css代码段链接/","text":"如题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364ActionScript: source.actionscript.2AppleScript: source.applescriptASP: source.aspBatch FIle: source.dosbatchC#: source.csC++: source.c++Clojure: source.clojureCoffeeScript: source.coffeeCSS: source.cssD: source.dDiff: source.diffErlang: source.erlangGo: source.goGraphViz: source.dotGroovy: source.groovyHaskell: source.haskellHTML: text.html(.basic)JSP: text.html.jspJava: source.javaJava Properties: source.java-propsJava Doc: text.html.javadocJSON: source.jsonJavaScript: source.jsBibTex: source.bibtexLatex Log: text.log.latexLatex Memoir: text.tex.latex.memoirLatex: text.tex.latexLESS: source.css.lessTeX: text.texLisp: source.lispLua: source.luaMakeFile: source.makefileMarkdown: text.html.markdownMulti Markdown: text.html.markdown.multimarkdownMatlab: source.matlabObjective-C: source.objcObjective-C++: source.objc++OCaml campl4: source.camlp4.ocamlOCaml: source.ocamlOCamllex: source.ocamllexPerl: source.perlPHP: source.phpRegular Expression(python): source.regexp.pythonPython: source.pythonR Console: source.r-consoleR: source.rRuby on Rails: source.ruby.railsRuby HAML: text.hamlSQL(Ruby): source.sql.rubyRegular Expression: source.regexpRestructuredText: text.restructuredtextRuby: source.rubySASS: source.sassScala: source.scalaShell Script: source.shellSQL: source.sqlStylus: source.stylusTCL: source.tclHTML(TCL): text.html.tclPlain text: text.plainTextile: text.html.textileXML: text.xmlXSL: text.xml.xslYAML: source.yaml 原址 50个代码段链接","tags":[{"name":"sublime","slug":"sublime","permalink":"http://yoursite.com/tags/sublime/"}]},{"title":"jquery.validate.js(智能表单验证)","date":"2015-08-02T11:03:30.000Z","path":"2015/08/02/jquery-validate-js-智能表单验证/","text":"在做网页表单时时常需要在客户端对表单填写的数据进行验证一番才能提交，我们可以通过自己编写JavasScript代码来验证，但是有时数据量过多时就会有些难度了。基于jQuery的jquery.validate验证框架帮我们解决了困难，我们可以通过它迅速验证一些常见的输入,并且可以自己扩充自己的验证方法，而且对国际化也有非常好的支持。 今天记录的就是用此插件来实现表单验证，效果图： 1、获取JS文件：http://jqueryvalidation.org/，这个插件的用法就不再多讲了，如不熟悉或者还没用过的可以通过官网了解也可以搜索jquery validate中文API，此文仅仅记录如何实现上图效果。 2、导入JS12&lt;script src=\"test/jquery.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;script src=\"test/jquery.validate.js\" type=\"text/javascript\"&gt;&lt;/script&gt; 3、创建表单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;fieldset style=\"width:700px; margin:0 auto;\"&gt; &lt;legend&gt;用户注册&lt;/legend&gt; &lt;form id=\"signupForm\" method=\"get\" action=\"\"&gt; &lt;p&gt; &lt;label for=\"firstname\"&gt;用户名：&lt;/label&gt; &lt;input id=\"firstname\" name=\"firstname\" type=\"text\" /&gt; &lt;span class=\"red\"&gt;*&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"realname\"&gt;真实名：&lt;/label&gt; &lt;input id=\"realname\" name=\"realname\" type=\"text\" /&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"password\"&gt;密 码：&lt;/label&gt; &lt;input id=\"password\" name=\"password\" type=\"password\" /&gt; &lt;span class=\"red\"&gt;*&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"confirm_password\"&gt;确 认：&lt;/label&gt; &lt;input id=\"confirm_password\" name=\"confirm_password\" type=\"password\" /&gt; &lt;span class=\"red\"&gt;*&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"email\"&gt;邮 箱：&lt;/label&gt; &lt;input id=\"email\" name=\"email\" type=\"text\" /&gt; &lt;span class=\"red\"&gt;*&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"tel\"&gt;电 话：&lt;/label&gt; &lt;input id=\"tel\" name=\"tel\" type=\"text\" /&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"address\"&gt;地 址：&lt;/label&gt; &lt;input id=\"address\" name=\"address\" type=\"text\" /&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"idcard\"&gt;证件号：&lt;/label&gt; &lt;input id=\"idcard\" name=\"idcard\" type=\"text\" /&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"degree\"&gt;学 历：&lt;/label&gt; &lt;select id=\"degree\" name=\"degree\"&gt; &lt;option value=\"-1\"&gt;请选择&lt;/option&gt; &lt;option value=\"1\"&gt;小学&lt;/option&gt; &lt;option value=\"2\"&gt;中学&lt;/option&gt; &lt;option value=\"3\"&gt;大专&lt;/option&gt; &lt;option value=\"4\"&gt;本科&lt;/option&gt; &lt;option value=\"5\"&gt;学士&lt;/option&gt; &lt;option value=\"6\"&gt;硕士&lt;/option&gt; &lt;option value=\"7\"&gt;博士&lt;/option&gt; &lt;/select&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"sex\"&gt;性 别：&lt;/label&gt; &lt;input type=\"radio\" id=\"rdoFemale\" name=\"sex\" /&gt;男 &lt;input type=\"radio\" id=\"rdoMale\" name=\"sex\" /&gt;女 &lt;input type=\"radio\" id=\"rdoSecret\" name=\"sex\" /&gt;保密 &lt;/p&gt; &lt;p&gt; &lt;input id=\"read\" name=\"read\" type=\"checkbox\" /&gt;&lt;label for=\"read\"&gt;同意相关条约&lt;/label&gt; &lt;/p&gt; &lt;p&gt; &lt;input class=\"submit\" type=\"submit\" value=\"Register\"/&gt; &lt;/p&gt; &lt;/form&gt;&lt;/fieldset&gt; 4、表单初始化样式123.red&#123; color:red;&#125;.submit&#123; width:80px;&#125;input&#123;height:22px; padding:2px;&#125; 5、验证代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485$(document).ready(function() &#123; //设置默认属性 $.validator.setDefaults(&#123; submitHandler: function(form) &#123; form.submit(); &#125; &#125;), //开始验证 $(\"#signupForm\").validate(&#123; rules: &#123; firstname: &#123; required: true, stringCheck:true, byteRangeLength:[4,15] &#125;, realname: &#123; minlength:5 &#125;, password: &#123; required: true, minlength: 5 &#125;, confirm_password: &#123; required: true, minlength: 5, equalTo: \"#password\" &#125;, email: &#123; required: true, email: true &#125;, tel: &#123; isMobile: true &#125;, address: &#123; stringCheck:true, byteRangeLength:[4,100] &#125;, read: &#123; required:true &#125;, degree: &#123; required:true, min:0 &#125;, idcard: &#123; required:true, isIdCardNo:true &#125; &#125;, //设置提示信息 messages:&#123; address:&#123; stringCheck: \"请正确输入您的联系地址\", byteRangeLength: \"请详实您的联系地址以便于我们联系您\" &#125;, read:&#123; required:\"请先阅读注册条约\" &#125;, degree:&#123; min:\"请选择学历\" &#125; &#125;, //设置错误信息存放标签 errorElement: \"em\", //指定错误信息位置 errorPlacement: function (error, element) &#123; if (element.is(':radio') || element.is(':checkbox')) &#123; var eid = element.attr('name'); error.appendTo(element.parent()); &#125; else &#123; error.appendTo(element.closest(\"p\")); &#125; &#125;, //设置验证触发事件 focusInvalid: true, //设置验证成功提示格式 success:function(e) &#123; e.html(\"&amp;nbsp;\").addClass(\"valid\").text('ok'); &#125; &#125;)&#125;); 到这里表单验证功能就初步完成了，可以试着预览一下效果，点击按钮提交你肯定发现不会进行验证，因为在验证中使用了一些自定义的方法，所以验证失效，那么继续读下去吧，接下来是实现验证的提示信息的个性化和自定义验证方法。 6、我们可以知道validate默认的提示信息是英文的，我们可以编写一个jquery.validate.message_cn.js文件来改变它的提示内容并让提示内容显示成中文的：1234567891011121314151617181920212223242526//定义中文消息var cnmsg = &#123; required: \"必需填写项\", remote: \"请修正该字段\", email: \"请输入正确格式的电子邮件\", url: \"请输入合法的网址\", date: \"请输入合法的日期\", dateISO: \"请输入合法的日期 (ISO).\", number: \"请输入合法的数字\", digits: \"只能输入整数\", creditcard: \"请输入合法的信用卡号\", equalTo: \"请再次输入相同的值\", accept: \"请输入拥有合法后缀名的字符串\", maxlength: jQuery.format(\"请输入一个长度最多是 &#123;0&#125; 的字符串\"), minlength: jQuery.format(\"请输入一个长度最少是 &#123;0&#125; 的字符串\"), rangelength: jQuery.format(\"请输入一个长度介于 &#123;0&#125; 和 &#123;1&#125; 之间的字符串\"), range: jQuery.format(\"请输入一个介于 &#123;0&#125; 和 &#123;1&#125; 之间的值\"), max: jQuery.format(\"请输入一个最大为 &#123;0&#125; 的值\"), min: jQuery.format(\"请输入一个最小为 &#123;0&#125; 的值\"), //自定义验证方法的提示信息 stringCheck: \"用户名只能包括中文字、英文字母、数字和下划线\", byteRangeLength: \"用户名必须在4-15个字符之间(一个中文字算2个字符)\", isIdCardNo: \"请正确输入您的身份证号码\",&#125;;jQuery.extend(jQuery.validator.messages, cnmsg); 可以看到此文件中有一个自定义验证方法的提示信息，这些验证方法也是让之前预览没有验证效果的原凶哦，validate插件提供自定义验证方法，继续完善 jquery.validate.message_cn.js(自定义验证方法来源于网络) 文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 字符验证 jQuery.validator.addMethod(\"stringCheck\", function(value, element) &#123; return this.optional(element) || /^[\\u0391-\\uFFE5\\w]+$/.test(value); &#125;, \"只能包括中文字、英文字母、数字和下划线\"); // 中文字两个字节 jQuery.validator.addMethod(\"byteRangeLength\", function(value, element, param) &#123; var length = value.length; for(var i = 0; i &lt; value.length; i++)&#123; if(value.charCodeAt(i) &gt; 127)&#123; length++; &#125; &#125; return this.optional(element) || ( length &gt;= param[0] &amp;&amp; length &lt;= param[1] ); &#125;, \"请确保输入的值在4-15个字节之间(一个中文字算2个字节)\");// 身份证号码验证 jQuery.validator.addMethod(\"isIdCardNo\", function(value, element) &#123; return this.optional(element) || isIdCardNo(value); &#125;, \"请正确输入您的身份证号码\");/** * 身份证号码验证 */ function isIdCardNo(num) &#123; var factorArr = new Array(7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2,1); var parityBit=new Array(\"1\",\"0\",\"X\",\"9\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\"); var varArray = new Array(); var intValue; var lngProduct = 0; var intCheckDigit; var intStrLen = num.length; var idNumber = num; // initialize if ((intStrLen != 15) &amp;&amp; (intStrLen != 18)) &#123; return false; &#125; // check and set value for(i=0;i&lt;intStrLen;i++) &#123; varArray[i] = idNumber.charAt(i); if ((varArray[i] &lt; '0' || varArray[i] &gt; '9') &amp;&amp; (i != 17)) &#123; return false; &#125; else if (i &lt; 17) &#123; varArray[i] = varArray[i] * factorArr[i]; &#125; &#125; if (intStrLen == 18) &#123; //check date var date8 = idNumber.substring(6,14); if (isDate8(date8) == false) &#123; return false; &#125; // calculate the sum of the products for(i=0;i&lt;17;i++) &#123; lngProduct = lngProduct + varArray[i]; &#125; // calculate the check digit intCheckDigit = parityBit[lngProduct % 11]; // check last digit if (varArray[17] != intCheckDigit) &#123; return false; &#125; &#125; else&#123; //length is 15 //check date var date6 = idNumber.substring(6,12); if (isDate6(date6) == false) &#123; return false; &#125; &#125; return true; &#125; 在文件中导入jquery.validate.message_cn.js文件1&lt;script src=\"test/jquery.validate.message_cn.js\" type=\"text/javascript\"&gt;&lt;/script&gt; 到这里表单的验证功能就做好了，现在预览的效果应该是这样的： 如果没是这样的效果那要好好看看是不是漏了哪一步呢？还有最后一步就是编写验证样式来实现个性化验证，那个正确（’√’）和错误（’×’）的提示是背景图片，我们可以从网上找到自己中意的小图标就行了，验证样式为： 1234567891011121314151617181920212223242526272829/** * @DO 校验的样式文件 * @DATE 2010-11-25 * @AUTHOR Frylan */ /*错误样式*/input.error &#123; border: 1px dashed red;background:yellow; padding:2px; &#125;select.error &#123; border: 1px dashed red; background:yellow; padding:2px; &#125;.error &#123; padding-left: 16px; margin-left: 2px; color:red; /*背景图片（校验未通过的’×’图标）*/ background: url(unchecked.gif) no-repeat 0px 0px; font-family:Verdana, Geneva, sans-serif; font-size:11px;&#125;/*验证通过样式*/input.valid&#123; background:#FFC; border:#09F solid 1px; padding:2px;&#125;select.valid&#123; background:#FFC; border:#09F solid 1px; padding:2px;&#125;.valid &#123; padding-left: 16px; margin-left: 2px; /*背景图片(校验通过的’√’图标)*/ background: url(checked.gif) no-repeat 0px 0px; font-family:Verdana, Geneva, sans-serif; color:#00F; font-size:11px;&#125; 当然这个只是我这个效果的样式，表单和验证样式都可以根据自己的喜好来设置。这些都做完之后再次预览就应该是文中开头那个的效果图片了。","tags":[{"name":"插件","slug":"插件","permalink":"http://yoursite.com/tags/插件/"}]},{"title":"背景图由中点开始放大方法","date":"2015-07-02T04:43:29.000Z","path":"2015/07/02/背景图由中点开始放大方法/","text":"如题12345678910111213141516171819202122232425&lt;style&gt; body &#123; background-color: #F2F2F2; &#125; .zoom &#123; width: 300px; height: 300px; border: 1px solid #CCC; margin: 100px auto; background-image: url(./images/bg.jpg); background-position: center; background-size: 100% auto; position: relative; transition: all 1.5s; &#125; .zoom:hover &#123; background-size: 120% auto; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"zoom\"&gt;&lt;/div&gt;&lt;/body&gt;","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"jquery实现图片无缝轮播显示（面试笔试有用）","date":"2015-03-19T18:43:29.000Z","path":"2015/03/20/浏览器调试工具修改代码直接关联到文件并修改-add-folder-to-workspace/","text":"添加文件夹到 workspace添加好后，右键一个文件，选择「Map to file system resource…」，在弹出的文本框中选择在 Workspace 中对应的文件： 添加映射文件 选择对应的本地文件比如我映射了 style.min.css 文件，那么现在你编辑元素面板中的样式，Chrome 就会实时保存本地的文件变更。 具体的文件映射规则可以到 Devtools &gt; Settings &gt; Workspace 中设置： PS: 如果你映射的是文件夹，像 all.js?v=4.1 之类带参数的请求是无法映射的。 参考资料","tags":[{"name":"调试工具","slug":"调试工具","permalink":"http://yoursite.com/tags/调试工具/"}]},{"title":"jquery实现图片无缝轮播显示（面试笔试有用）","date":"2015-03-15T13:43:29.000Z","path":"2015/03/15/jquery实现图片无缝轮播显示/","text":"克隆图片案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;图片无缝轮播显示&lt;/title&gt;&lt;script type=\"text/javascript\" src=\"./jquery.js\"&gt;&lt;/script&gt;&lt;style&gt; .box,.box2&#123; width:800px; height:260px; margin:160px auto; overflow:hidden; position:relative;&#125; .box,.box2 p&#123; text-align:center;&#125; .picBox,.picBox2&#123; margin:0px; padding:0px; list-style:none; width:1500px;&#125; /* &lt;!--此处很关键，在实现无疑轮播时这个宽度一定要比显示图片数量+1的宽度宽--&gt; */ .picBox:hover,.picBox2:hover&#123; cursor:pointer;&#125; .picBox li,.picBox2 li&#123; float:left;&#125; .picBox img,.picBox2 img&#123; width:200px; height:240px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt; &lt;p&gt;第一种图片轮播：非无缝轮播&lt;/p&gt; &lt;ul class=\"picBox\"&gt; &lt;li&gt;&lt;img src=\"images/1.jpg\"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/2.jpg\"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/3.jpg\"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/4.jpg\"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/5.jpg\"/&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"box2\"&gt; &lt;p&gt;第二种图片轮播：无缝轮播&lt;/p&gt; &lt;ul class=\"picBox2\"&gt; &lt;li&gt;&lt;img src=\"images/1.jpg\"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/2.jpg\"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/3.jpg\"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/4.jpg\"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/5.jpg\"/&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;script&gt; $(function()&#123; // &lt;!--第一种图片轮播：非无缝轮播--&gt; function rollOne()&#123; $(\".picBox li:first\").animate(&#123;left:\"-=200px\"&#125;,\"linear\",function()&#123; $(this).remove().clone(true).appendTo(\".picBox\").fadeIn(\"slow\"); &#125;); &#125; var startRollOne=setInterval(rollOne,2000); // &lt;!--鼠标移入停止移出继续--&gt; $(\".box\").hover(function()&#123; clearInterval(startRollOne); &#125;,function()&#123; startRollOne=setInterval(rollOne,2000); &#125;); // &lt;!--第二种图片轮播：无缝轮播--&gt; // &lt;!--这种无缝轮播可以通过设置animate动画播放速度值和setInterval中的函数调用时间间隔实现间隔无缝轮播--&gt; function rollTwo()&#123; $(\".picBox2\").animate(&#123;marginLeft:\"-200px\"&#125;,2000,\"linear\",function()&#123; $(\".picBox2\").css(&#123;marginLeft:\"0px\"&#125;); $(\".picBox2 li:first\").remove().clone(true).appendTo(\".picBox2\"); &#125;) &#125; var startRollTwo=setInterval(rollTwo,2000); // &lt;!--鼠标移入停止移出继续--&gt; $(\".picBox2\").hover(function()&#123; clearInterval(startRollTwo); &#125;,function()&#123; startRollTwo=setInterval(rollTwo,2000); &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"jQ轮播图","slug":"jQ轮播图","permalink":"http://yoursite.com/tags/jQ轮播图/"}]},{"title":"jQuery记忆与问题（面试笔试有用）","date":"2015-03-15T01:43:29.000Z","path":"2015/03/15/jQuery记忆与问题/","text":"【jQuery操作一定要做变量本地化】（功能强大，必定效率不高）1、本地化的意思是把 var dom = $(“dom”);这样就是变量本地化（这样做原因是，$的属性方法很多，效率不高，本地化就是提高效率）【入口函数】1、JQ入口函数，是在页面dom元素加载完毕后就开始加载JS入口函数等页面全部加载完再加载（包括图片）【width()和innerWidth()】1、.width() 只能获取内容的宽度2、.innerWidth（）获取包括padding内的宽度不包括边框3、.outerWidth() 获取包括border在内的宽度，不包括margin4、.outerWidth(true) 获取包括margin在内的宽度【jq的offset().left】1、jq的offset().left获取离窗口的左边距，与有定位父级无关 和JS不同 【.children(“p”)和.find(“p”)】1、都可以寻找后代，但find能找后代的后代，children不能 【$(“li:gt(2):lt(9)”)】1、这里意思是 从第3个Li 选择 到第13个li 连写后面的lt是代表 从第三个开始角标为0计算 【end()和addBack()】1、 .end() 选择前一级的元素2、 .addBack() 选择前面所有的元素 【$.trim(str)】1、 清除字符串里面的空格 【清除冒泡或清除默认事件】1、return false // 不能清除冒泡，只能清除默认事件2、event.stopPropagation() //清除冒泡3、event.preventDefault // 不能清除冒泡，只能清除默认事件4、JQ triggleHandler() // 清除冒泡，清除默认事件 【表单序列化】（当表单用JQ的ajax方法）1、data : $(&#39;#my_form&#39;).serialize(); （前提:表单input里面的name要与php文件里面的参数(.GET(“name”))要一致） 【remove()和empty()】1、$(“ul”).remove(); 直接删除ul节点2、$(“ul”).empty(); 删除ul里面所有内容，不包括ul 【$(window)】1、 window不用双引号 【delete】（JS的方法）（案例看jq的备忘录删除功能）1、delete删除掉数组中的元素后，会把该下标出的值为undefined，数组的长度不会变 【continue】1、jQ里面的$.each()方法不能使用continue;只能用原始的for循环才能使用 【普通事件和委托事件】1、obj.click() 和 parent .on(“click”,obj,function(){}) 当用JS动态创建的dom元素就必须用委托on去绑定事件 其余都用.click(); 【data】eg: &lt;li data-xxx=&quot;xxxxx&quot;&gt;aaa&lt;/li&gt; (这里aaa是展现，xxxxx是跟这个li相关的数据)1、 自定义属性data- * 通过DOM存储于DOM对象强相关的数据2、 JS源生获取data dom.dataset[“xxx”];3、 JQ $(“obj”).data(“xxx”); 【备忘录学习地方】(JQ备忘录)1、store插件的使用 store.set(“arr1”,arr) store.get(“arr1”) store.clear(); store能保存本地数据，下次刷新的时候数组不会清空 **每次更改数组内容 都要更新store.set(“arr1”); 因为store存储的数据会根据浏览器自动选择使用 localStorage、globalStorage 或者 userData 来实现本地存储功能。 2、通过{}创建对象作为备忘录项，并添加到数组里 3、delete删除掉数组中的元素后，会把该下标出的值为undefined，数组的长度不会变,原本的下标不会改变 4、continue:jQ里面的$.each()方法不能使用continue;只能用原始的for循环才能使用 5、$.trim(str) 6、时间戳 (new Date()).getTime() 7、jq获取日期时间的插件 【$.extend】(写JQ插件的)(JQ)1、原理 $.extend(json1,json2); 如果2者有相同属性，json2会覆盖json1的该属性 2、写插件要写css 和 js 2个文件 3、js 默认样式123456(function($)&#123; $.fn.extend(&#123; myFn : function()&#123;&#125; &#125;) &#125; )(jQuery) 4、日后写框架，用闭包更安全123var initTab = (function($)&#123; function init()&#123;&#125; return init;&#125;)(jQuery)initTab(); //return","tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"JS基础笔记（面试笔试有用）","date":"2014-12-15T12:43:29.000Z","path":"2014/12/15/AJAX笔记/","text":"【AJAX标准写法】(记忆)1234567891011121314151617181920// 创建xhrif(window.XMLHttpRequest)&#123; // 5种判断方式（window,typeof,try-catch,in,判断浏览器） var xhr = new XMLHttpRequest();&#125; else &#123; var xhr = new ActiveXObject(\"Microsoft.XMLHTTP\");&#125;// 连接xhr.open(\"get\",url,true);// 发送xhr.send();// 接收xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304)&#123; alert(xhr.responseText); // 返回文本内容 &#125; else &#123; alert(xhr.status) // 如果前面有错误则返回404 &#125; &#125;&#125; 【jsonp封装注意地方】(url,data,cbName,success,error,timeout)1234567891011121314151617181920212223242526272829303132333435363738394041function jsonp(options)&#123; options = options || &#123;&#125;; if(!options.url) return; options.data = options.data || &#123;&#125;; options.cbName = options.cbName || \"cb\"; // 不同的搜索引擎的回调函数不一样 百度 \"cb\" 360 \"callback\" options.timeout = options.timeout || 0; var fnName = (\"jsonp_\" + Math.random()).replace(\".\",\"\"); // 给回调函数添加随机因子 var arr = []; options.data[options.cbName] = fnName; // 添加回调函数 for(var name in options.data)&#123; arr.push(name + \"=\" + encodeURIComponent(options.data[name])); &#125; var str = arr.join(\"&amp;\"); //2 全局函数 window[fnName] = function(json)&#123; // window[fnName]为全局函数，局部函数声明全局变量用window好维护 // 这里的json，是fnName这个回调函数返回过来的数据（默认） options.success &amp;&amp; options.success(json); window[fnName] = null; // 把函数清空，释放内存，减少浏览器性能的消耗 oHead.removeChild(oS); // 每次调用全局函数，清除head头里面的script标签 clearTimeout(timer); &#125;; //1 创建script var oS = document.createElement(\"script\"); oS.src = options.url + \"?\" + str; var oHead = document.getElementsByTagName(\"head\")[0]; oHead.appendChild(oS); if(options.timeout)&#123; var timer = setTimeout(function()&#123; options.error &amp;&amp; options.error(); window[fnName] = function()&#123;&#125;; // 接受超时，要把全局函数赋值为空函数，不然会报错 oHead.removeChild(oS); &#125;,options.timeout); &#125;&#125; 【ajax的上传方式get post】1、 get : 有缓存 post : 没缓存（相对安全，信息不会暴露在地址栏） 【表单】(刷新整个页面)1、表单三要素 （一）action:地址 （二）name:上传的名字 （三）value:上传的值 2、method ——— get: 数据在地址栏上显示 不安全 32K post: 数据隐藏 相对安全 1G 【缓存问题】1、缓存： 浏览器对同一个的地址只会访问一次，再次加载也是重新记录上一次的东西 （IE缓存严重） 解决： 让地址不一样 ———————–（1）添加随机数 t=Math.random(); ———————–（2）时间戳 new Date().getTime(); 【try catch】(一般不用，性能差)1、12345try&#123;// 可能出错代码&#125; catch(e)&#123;// 补救代码&#125; catch里的e参数 必须有，获取报错信息 【typeof特殊用法】12.221、12console.log(a) // 报错console.log(typeof a); // 返回undefine，但不报错*用于兼容判断IE，不报错2、（面试）1console.log(typeof (typeof a)) // string【后台文件传过来的json的一些注意事项】1、后台传输过来的数据一定是string类型，如果要通过JS接收后台数据就要转换指定的类型 eval(‘(‘+json+’)’); (jq方法接收数据不能用eval，不然会报错) JSON.parse(json字符串)2、AJAX解析后台资源，通过JSON.parse（）转换 等同于 eval(&quot;(&quot;+json+&quot;)&quot;)，后者动态函数，要做赋值操作，不然报错;json转string】 2、JSON.stringify(json); (固定写法)但不兼容IE 6 7json转num】 3、eval(&#39;(&#39;+json+&#39;)&#39;); // 因为json是大括号包着，但有大括号系统会去寻找上边的是否缺少东西如是否缺少for function if等语句，会报错 // 所以要在json外面添加（json）json标准格式】 4、 属性名必须是双引号，值如果是字符串也要双引号，但如果要用单引号的话，外面要用转义字符/‘abc/‘【undefined 和 not defined】1、undefined是JavaScript语言中定义的五个原始类中的一个，换句话说，undefined并不是程序报错，而是程序允许的一个值。not defined是javascript在运行我们的javascript代码时，遇到没有定义就用来运算的变量或者变量是个方法时报出来的错误。【编码方式】1、编码 encodeURIComponent(&#39;str&#39;)&#39; 中文编码成ASCII码1、解码 decodeURIComponent(&#39;%21%323%234&#39;)&#39;地址栏里面只能是ASCII编码组成，如果有中文要进行编码操作【HTTP状态码】 三个数字组成 第一位代表类型1XX 请求已经接受，正在处理2XX 成功3XX 重定向 （3以内只有304成功（第二次打开浏览器，会把自己第一次的缓存与服务器相关的东西的最后修改时间进行对比，如果相等就返回304））4XX 错误 ———&gt;前台错误5XX 服务器错误 ———&gt;后台错误 （503错误，服务器超载，内存被塞满，例子：12306太大访问量，就会出现503错误）【eval】1、标准格式 eval(&quot;(&quot;+str+&quot;)&quot;)【replace】1、字符串替换 str.replace(&quot;被替换的字符串&quot;，&quot;替换者&quot;)【80端口】1、所有网页都默认是80端口【jsonp】1、JSONP(JSON with Padding)是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。写法：1、创建一个script标签2、定义一个全局函数跨域:只要域名 端口 协议任意一个不同就算跨域 （后台不存在跨域问题，只有前台）前端跨域时，数据必须有名接受，没名字的数据前端拿不了，只能通过后台中转网址的组成: http:// www .520it .com :80 /index.html 协议 二级域名 一级域名 域名后缀 端口 资源地址ajax跨域解决方法（逐步深入理解跨域实现原理）1. Script的src方式加载js文件（script可以引入任意的文件(通过script引入地址的方式获取其他服务器上的信息)）2. 加载的js文件内进行函数调用3. 数据以函数参数的形式传递4. 回调函数中获取参数数据（回调函数就是下面的show把json的东西返回给页面）https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=aaa&amp;cb=showwd: word 关键字cb: callback 回调函数img标签的src不用通过appendChild() 就可以访问src地址script等其他标签 都不能 必须添加【ajax与jsonp是两回事】 【window a】1、在局部函数内定义全局变量 用window去定义，在局部函数里这样写容易维护 (前提要调用局部函数，才会产生全局变量) 2、 eg123456function a()&#123; var b = 3; var 一直为局部变量 console.log(b);&#125;a(); console.log(b); //最后打印1,然后报错 123456function a()&#123; window.b = 3; window.b 要调用后才能为全局变量 console.log(b);&#125;a(); console.log(b); //最后打印1,1 1234567function a()&#123; window.b = 3; window.b 要调用后才能为全局变量 console.log(b);&#125;console.log(b);a(); console.log(b); //最后报错 【绑定】(绑定多个事件)（false：代表冒泡 true：代表捕获 （浏览器事件流就是指冒泡，捕获））1、obj.addEventListener(“事件名”，函数,false) // IE 9+ eg: document.addEventListener(&quot;click&quot;,fn,false); 2、obj.attachEvent(&quot;onclick&quot;,fn) // IE 6 7 8 【网络延时】（onload 是 window img script的属性）1、可以用obj.onload方法去包裹需要服务器返回的数据，但不兼容IE (“onload” in obj) 判断兼容方法 IE用obj.onreadystatechange 2、因为JS是先加载页面的标签和图片后再执行 JS代码， 如果window.onload = function(){ img.onload = function(){console.log(1);}}; *不会读取到console.log(1); 【浏览器默认行为与绑定解绑事件的混合使用】1、event.preventDefault 和 return false 都可以取消默认行为 【事件委托】（提高效率，不用循环多次）1、原理：冒泡 （给对做事件的元素的最大父亲添加对应事件,点击子元素弹出指定元素）event.srcElement 兼容chrome ieevent.target 兼容chrome oz var oSrc = event.srcElement || event.target 【target事件和currentTarget】（看事件委托内含高级排他）1、target在事件流的目标阶段；currentTarget在事件流的捕获，目标及冒泡阶段。只有当事件流处在目标阶段的时候， 两个的指向才是一样的， 而当处于捕获和冒泡阶段的时候，target指向被单击的对象而currentTarget指向当前事件活动的对象（一般为父级）。 2、target.id 、 target.tagName eg:123456789ul.onclick = function(e)&#123; var e = e || event; var oSrc = e.target; var oSrcTagName = e.target.tagName; console.log(e.target.tagName) // 返回点击元素的标签名 console.log(e.target) // 指点击的元素 console.log(e.currentTarget); // 指ul&#125; 【AJAX是在浏览器和服务器之间架一层AJAX引擎作过滤，筛选】","tags":[{"name":"ajax","slug":"ajax","permalink":"http://yoursite.com/tags/ajax/"},{"name":"jsonp","slug":"jsonp","permalink":"http://yoursite.com/tags/jsonp/"}]},{"title":"JS基础笔记（面试笔试有用）","date":"2014-12-15T12:43:29.000Z","path":"2014/12/15/JS进阶/","text":"【定义@keyframes】1、 0% { opacity: 0;} 100% { opacity: 1;} *千万别在后面家逗号或者分号【html,body】1、html,body { width:100%; height:100%;}为什么这样写，是因为有些浏览器body高度并不是占满页面，这样设置保证body得到全屏宽高（做整屏动画要考虑） 【document.body.offsetHeight和document.body.clientHeight】1、前者获取body标签高度，后者获取窗口（视口）高度,两者不一样 如果body不设置高度，前者会等于0，后者等于视口宽度 2、document.body.offsetWidth 获取到的是包括滚动条的宽度 反而document.body.clientWidth 不包括滚动条 【防止拖动时选中内容】1、window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty(); 2、直接在函数体最后return false; 【js单引号双引号问题】1、Json 里如果要用引号，建议使用双引号，这样别的语言也能识别数据 2、JS为什么要用单引号，是因为JS都把内容或者样式插入行内，标签属性定义时一般用双引号，JS赋值的时候用单引号，不容易出错 【直接改变数组的值】1、123var arr = [1,3,5,6];arr[3] += 1;console.log(arr); // [1,3,5,7] 【转换标准json格式的网站】1、bejson网址 【Math.min.apply(null,arr)】1、这是一种获取数组里面最小数的一种方法，是通过function.apply(this,arguments)，反之取大值就改变前面的方法Math.max **apply详情可以查看 【冒泡事件注意事项】1、冒泡事件只能禁止同类型事件1234567btn.onclick = function(e)&#123; e.stopPropagation(); console.log(1);&#125;wrap.onmousedown = function()&#123; console.log(2); // 打印 2 1&#125; 2、爷父子三个盒子，如果在父盒子中阻止冒泡事件，那么子盒子也不会冒泡到爷盒子上，只会冒泡到父盒子上 3、父盒子绑定事件，子盒子没有绑定事件（子盒子有宽高），如onmouseover，在父盒子和子盒子来回移动会不断触发事件发生， 如onclick(1218自己做的登录窗口点击消失案例中，点击box里面的有高度的hd盒子也会消失，移动的时候前提要先onmousedown触发，如果不能触发可能是点击事件冒泡有影响) 这是子盒子的冒泡事件，解决办法在父盒子设置计数器，当触发的时候等于1，大于1的时候不在触发 【document.body.scrollTop能读值取值】1、document.body.scrollTop能被赋值 【this】（面试） 0、只要有闭包事件，它的调用者就是window,this就指向window，没有任何特殊情况 *如果this指向undefined1、this: this所在的函数在哪个对象中，this就指向对象（大部分情况） eg:123456function dog()&#123;console.log(this); &#125; dog(); //this指向window，因为所有的全局变量和所有的函数都是window的属性和方法 new dog() //this指向dog，new 关键字可以让 this 指向新的对象，这就是所谓的构造函数 2、少数情况特殊: （1） 如果this在定时器中, this就指向window （2） 如果this在事件源中, this就指向产生这个事件源的对象 **解决方法用备份指针 var self = this; 【构造函数的prototype】(面试)1、是为了共享属性和方法，不用的话，每一个构造函数的实例都会各自创建新的方法，会消耗内存，如果用了原型，就会让所有的实例共用这个方法，只开辟 一次内存 【;(function(){})()】1、;为了防止前一个封闭作用于没有小括号导致后面的闭包变成实参 【H5新标签】 1、seletor.classList.add(&quot;class&quot;);2、seletor.classList.toggle();","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"JS基础笔记（面试笔试有用）","date":"2014-12-11T10:23:29.000Z","path":"2014/12/11/JS基础笔记（面试笔试有用）/","text":"【if判断‘=’和‘==’问题】千万记着以后都写双等于去判断1、if( i = 0)和if( i == 0)第一个是赋值操作判断语句(这样写容易进入死循环除非是true和false的情况) 第二个才是正常情况 【for循环的】1、先声明变量 后判断终止条件 再执行括号内容 最后++i2、对于for循环 i++和++i都可以使用，++i的内存应用效率更高，在转化成汇编语言的时候，会少开辟一个变量 【字符相加和相减的类型变化】1、5 + ‘8’ 和 ‘5’+‘8’打印结果为58(最终都转换为string类型) 5 + 8 =13 num 类型2、‘8’ - 5 和 ‘8’ - ‘5’ 和 8 - 5 打印结果都为3（最终都转换为num类型）3、 ‘asd’ - ‘zcx’ 打印结果未NaN(最终结果为num类型) 【释放内存和销毁变量】1、函数调用完后，立即销毁函数内的局部变量 【style和script的位置】1、style样式一般写在里面，但实际上可以写在body里面或者其他位置，但这就会涉及到浏览器渲染顺序问题，style标签写在body里CSS会重新渲染一次页面，占用一定时间，如果网页篇幅少的话感觉不出来，如果篇幅多（大量HTML）会有一定的影响，所以大页面中不建议将style写进body（就像一些电商网站，有部分CSS写在body里面，这是为了方便修改源代码，否则你还得去翻CSS比如网站左侧、右侧的广告模块，很多页面都要加入这个广告，所以他就把广告这一块的html写到一个文件里，然后在加载过来。所以css也和他写在一起。） 【淘宝搜索框 oninput&amp;&amp;onpropertychange】1、 打字label文字就消失，清空文字就显示原本的label文字12345678910111213141516window.onload = function()&#123; function $(id)&#123;return document.getElementById(id);&#125; //oninput 大部分浏览器支持 检测用户表单输入内容 //onpropertychange ie678 检测用户表单输入内容 $(\"txt\").oninput = $(\"txt\").onpropertychange = function()&#123; if(this.value == \" \") &#123; $(\"message\").style.display = \"block\"; &#125; else &#123; $(\"message\").style.display = \"none\"; &#125; &#125;&#125; 2、&lt;input type=”text” placeholder=”必败的国际大牌” 同样得到上面的效果 placeholder是H5 input的新属性 这2种写法避免多重判断光标位置，是否打字等， 【算法、关系、逻辑运算符的关系】1、逻辑运算符（!,&amp;&amp;,||）与操作：egvar result=true&amp;&amp;3 //3var result=1&amp;&amp;3 //3var result=false&amp;&amp;3//falsevar result=””&amp;&amp;3 //“” (前面根据booler类型决定 true就取最后一个true的值 false就取false的值) 或操作：如果第一个值为真则结束后面的判断 （true就取第一个true的值 false就取最后一个false的值) 2、优先级—————-算术运算符》关系运算符》逻辑运算符 运算符顺序 1 () 2 !、-、++、– (-10) 负号 正号 3 *、/、% 4 +、- 10-5 5 &lt;、&lt;=、&lt;、&gt;= 6 ==、!=、===、!==、 7 &amp;&amp; 8 || 9?: 10 =、+=、-=、*=、/=、%= 赋值 【window.getComputedStyle(“元素”, “伪类”)[attr]】（伪类位置默认为null）1、获取一个元素的属性集合用法：getComputeStyle(element,null).width 优点：解决obj,style[attr]只能去行内样式的缺陷 缺点：因为要得到全部属性集合才能取想要的值，所以是非常耗内存的操作 【eval】（一般不用，以防面试会问）1、eval方法是开启程序解析器的入口，对于js程序来说，当程序运行的时候，会开启一次程序解析器，会解析对应的代码，当我们 使用eval函数的时候会再次开启程序解析器，会解析eval中的内容2、可以用来让浏览器自己识别简单的算法运算并得出结果 3、eval原理 去掉字符串的冒号，变成非string类型 【JS的数组和别的语言数组最大区别】1、JS同一个数组能同时存放不同的数据类型，别的语言只能存贮相同类型的数据类型 【全选与反选得出的取反思想】1、123456btns[1].onclick = function () &#123; for(var i =0;i &lt;inputs.length;i ++)&#123; //左边的设置值，右边的是取值 inputs[i].checked = !inputs[i].checked; &#125;&#125; 这种方法一般是控制dom元素的属性值，！这里是关键，因为一般属性判断只有2个值true 和 false，用这种方法会比较简洁; 【window.location.href】1、页面跳转方法 【定时器的本质】1、Interval定时器：在外设置1s间隔循环一次，如果里面的程序需要2s才能运行完毕，那么最终时间2s （一个定时器，外面设置间隔时间，里面也有执行时间，最终时间按长的时间计算）2、TimeOut定时器：间隔时间+程序执行时间 = 最终时间； 这里涉及队列问题，有异步的思想在里面，原理是定时器的运作会与定时器里面的程序同时启动，如定时器间隔1s运行1次，里面程序2秒才能执行完程序，那么定时器会与里面程序同时执行（异步）当定时器1s过完后，必须要等待里面程序执行完毕才能执行下一次定时器循环，而这里由于定时器的1s已经完成，所以下一次循环会立刻开启 3、函数声明放在定时器外面，能提高效率，避免每一次定时器循环都声明变量开辟新的内存，这样会耗用性能 【元素的类型判断nodeType】1、nodeType = 1 为元素节点2、nodeType = 2 为属性节点3、nodeType = 3 为文本节点 4、用法** （可以在循环内判断nodeType类型去添加不同节点类型） 【array.srot()】（面试可能会问）1、sort（）原理是通过ascII编码顺序去排列，是按照数组的值的首字母或者首位数字去进行由大到小排列，所以是不精准的 如果需要按顺序由大到小或者小到大完整排列，必须在sort()括号里添加一个参数去判断比较a,b值大小， * 详情查看W3C 【document.body】1、如果在用 document.body.appendChild(); 生成的元素会插在的后边 (原因是浏览器解析的时候会把标签放到body内) 【innerHTML和value】1、获取文本，&lt;input&gt;和&lt;textarea&gt; 必须用.value 【offsetLeft的位置】1、offsetLeft是相对于有定位(无论相对定位还是绝对定位)的父盒子(offsetParent) 没有就找body去找位置 【json的一些注意事项】1、json是无序的，不能用下标去表示2、访问里面的值，可以用点语法，也可以用[]如果用json[‘key’] 那么json里面的键值对的键可以用引号也可以不用引号都能获取 如果用json.key 怎么取值都能获取,但不能写成json.’key’; 3、反正想着获取的key值 是否是字符串就可以选择相对应的方法 【抽取工具类的原因】（面试）1、提高代码扩展性，可以举 12.7最后一个例子 json—-myfn的例子去解释 （是一个由获取id tagname 到 for循环的抽取例子） 这个封装的each方法，只是作了声明 和 调用 ，所以赋值在调用each的时候才真正完成一个函数的调用 【右键事件】1、document.oncontextmenu = function(e){} document是最大的事件源e是事件源 兼容ie的方法 var e = e || event; 2、return false;能清空默认右键事件并且不影响自定义事件 【e.currentTarget】1、用来获取当前的事件源是谁 类似于this 【for循环的另一种写法】（思想一致）（遍历最里层盒子到页面边的距离）1、123456var box2 = document.getElementsByTagName('div')[2];var sum = 0;for( var i = box2; i.offsetParent; i = i.offsetParent)&#123; sum += i.offsetLeft + i.offsetParent.clientLeft;&#125;console.log(sum); 【offset和client前缀】1、offsetWidth,offsetHeight 是 content + padding + border 的距离 ** document.body.offsetHeight 获取标签高度 offsetLeft,offsetTop 是到最近的有定位的父级的距离（不包含该父级的边框） 2、clientWidth,clientHeight 是 content + padding 的距离 * document.body.clientHeight 获取页面视口高度（与上面不一样） clientLeft,clientTop 是该元素border的厚度 3、parentNode和offsetParent parentNode是找父盒子（最深找到HTML标签） offsetParent是找有定位的父盒子（最深只找到body标签） 【获取屏幕分辨率（就是显示屏的）】1、window.screen.width / window.screen.height 【闭包的原理】1、闭包的作用:延长局部变量的生命周期 （同时，弊端就会大量占用内存） 2、需求1:想要在函数外面（另外一个函数中）访问某一个函数内部的局部变量 【for循环内部的一些原理】1、在for循环遍历按钮时，如果要在按钮输出变量i，会得到最后的i值，这是因为按钮、定时器等都是延时操作，只要有延时操作最终输出的变量都是i值，因为在按钮点击或者触发定时器的时候外层的for循环已经完成。（基本我接触到的里面任何函数操作都是延时操作,除了闭包) eg:12345678var div = document.getElementsByTagName('div');for( var i = 0; i &lt; div.length; ++i)&#123; (function(a)&#123; div[i].onmouseover = function()&#123; console.log(a); &#125; &#125;)(i)&#125; **这里闭包里面的div[i] 为什么能获取i的值，就是因为外面的闭包不是延时操作，所以可以遍历所有的div; 【btn.onclick = function(){}】1、为什么这里的匿名函数funtion(){} 不能传入普通参数进行操作，是因为这里的参数是代表前面btn的onclick事件源， btn.onclick = function(a){ console.log(a); //返回ClickEvent{} （代表事件源） } btn.onclick 等于号后面是一个函数体，要有click出发才会执行，所有不应该有小括号立即调用，所以也不存在有普通参数传递的原因，但事件参数a会一直存在 【字符操作】1、（获取数字） indexOf(‘string’) 括号里放获取位置的字符 从左向右顺序，没有该字符就返回-1； else:(lastIndexOF(‘strinig’)) 从右向左找，但返回的数字也是从左向右 2、（获取字符） charAt() 括号里放对应字符的位置去获取相应字符3、 charCodeAt() 去对应字符的Unicode编码 普通编码‘0-127编号’ 中文的编码是大于127 而且中文占2个字符的位置**Unicode和askcII 【ClientY和PageY（不兼容IE）】1、e.ClientY 只能获取视觉上的页面顶部2、e.PageY 获取页面最顶部，不管是否有滚动条 【for里面定义的变量是全局变量】1、for里面定义的变量是全局变量 2、var a = 1; var a = 2; //第二个var被自动忽略 console.log(a); //2**JS容错率很高，当检测到第一个var a的时候会向内存开辟一个空间，后边的重复声明a都会自动忽略var 这是引擎处理程序问题，要了解要自己百度【透明度兼容】1、opacity: 0.4; W3C浏览器2、filter: alpha(opacity:40); 兼容IE","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"HTML5项目笔记","date":"2014-12-10T04:20:29.000Z","path":"2014/12/10/HTML5项目笔记/","text":"【webstrom快捷键】1、Ctrl + “+/-“ 收缩标签2、Ctrl+Shift + “+/-“ 收缩全部标签3、Ctrl+Alt+L 自动格式化 全套快捷键在HTML5项目里的doc文件 【字体图标】1、以后用阿里云的字体库，阿里云有unicode编码*2、由于google浏览器设置的最低font-size是12px，要改变字体图标大小，添加inline-block，之后再进行-webkit-transform: scale(0.7)进行缩放","tags":[{"name":"HTML，CSS，WebStrome","slug":"HTML，CSS，WebStrome","permalink":"http://yoursite.com/tags/HTML，CSS，WebStrome/"}]},{"title":"HTML+CSS笔记","date":"2014-12-08T04:20:29.000Z","path":"2014/12/08/HTML+CSS笔记/","text":"【清除浮动】1、父盒子给高度2、父盒子给overflow: hidden;3、在同级元素尾部添加标签并增加样式 clear: both;【表单】1、所有具有功能的标签（input,select…）都要放在form表单中才能生效2、1234567&lt;form&gt; &lt;fieldset&gt; &lt;legend&gt;用户注册&lt;/legend&gt; &lt;input type=\"text\"&gt; ....... &lt;/fieldset&gt;&lt;/form&gt;fieldset和legend能使一个边框上有文字生成，一种格式。【dl&gt;dt+dd】1、图文混排就想到 dt+dd 增强语义化 （float:left;）【figure标签】1、语义化媒体标签1234&lt;figure&gt; &lt;figcaption&gt;&lt;/figcaption&gt; &lt;div&gt;&lt;/div&gt;&lt;/figure&gt;【datalist】1、数据绑定123456789101112131415&lt;input id=\"myCar\" list=\"cars\" /&gt;&lt;datalist id=\"cars\"&gt; &lt;option value=\"BMW\"&gt; &lt;option value=\"Ford\"&gt; &lt;option value=\"Volvo\"&gt;&lt;/datalist&gt;``` 【details】1、被折叠的内容 像二级树``` HTML&lt;details&gt; &lt;summary&gt;打开&lt;/summary&gt; 打开的内容&lt;details&gt;【marquee】（类似弹幕）1、滚动的标签（W3C没有，但是浏览器都支持）HTML &lt;marquee&gt;&lt;/marquee&gt;2、属性 (移动方向)direction=”left/right/up/down”(移动速度)scrollamount=”10”(循环次数)loop=”2”(滚动类型)behavior=”alternate/slide” (来回/一次停住)【inherit】1、麻烦的属性不想再写一遍，在子元素属性添加:inherit（前提：父元素有该属性）【圣杯布局、双飞翼布局】(在1112资料里)1、不用flex能自动缩放2、适用一切浏览器 【垂直水平居中的2种方式】1、绝对定位后 left：50%；top:50%; margin-left:(-width/2)px;2、绝对定位后 left:0;top:0;bottom:0;right:0;margin:auto; (这是特殊方法) 【background-attachment:fixed;】1、背景图做固定定位，移动滚轮才有效果 【快捷写法】1、ul&gt;li{内容} 中括号添加标签里内容2、ul&gt;li.num$*3 生成3个num1 num2 num3类名的li 【兄弟选择器】1、+ 其后一个2、~ 其后全部元素 【::selection】1、鼠标选中文字时，改变选中后的样式 【overflow:hidden是能切割一切盒子外的地方】1、嵌套层的盒子即使相对父盒子绝对定位，父盒子只要设置overflow:hidden；超出盒子范围的任何子元素都会隐藏 z-index设置多大也不会出现。 【对伪对象的hover】1、 * div:hover::after 并不是 div::after:hover 【transform一些特性】1、只要在该标签使用 scale rotate translate 的动作的瞬间，就相当于脱离文档流呈现在最上方，除有z-index&gt;1以外不能覆盖，不然都能覆盖2、变化的时候margin,padding都会根据属性变化发生改变，但不会把原来的位置撑开 **记着变化的瞬间，相当于脱离文档浮在最上面 【transition-origin】1、定的位置要在本元素上写，不要写在:hover上写（这样写起点不断改变） 【transform-style: preserve-3d;】1、三维属性要添加在父级上，里面的元素才可以进入三维空间2、进入三维空间后，如果给父盒子添加维度属性，要按照三维空间去考虑，整体缩放或者移动会得到想要的结果 （eg:scale3d(x,y,z)）3、只要给transform 父盒子 里面的元素都会改变4、旋转都是顺时针为正方向 【@font-face 字体图标】1、小码哥1120 里面有最兼容的方法（第二种）日后就写这种(原理：unicode是字体在网页端最原始的应用方式)(Unicode(统一码、万国码、单一码)是一种在计算机上使用的字符编码) 【媒体查询范围值】1、 PC @media（min-width:981px）{}2、 Pad @media(min-width:621px) and (max-width:980px){}3、 Phone @media(max-width:620px){}4、 日后写媒体查询加上 @media screen (…){…} 加上screen 是保证只给有屏幕的且支持H5的设备观看 【外链媒体查询（提高加载效率）】1、 2、 3、 【响应式网站写CSS】1、写样式的时候尽量把PC的 嵌套写法都写进去，这样保证权重一致，方便日后修改 【position:fixed;被覆盖问题】1、如果都不设置z-index 后面的也会覆盖固定定位的盒子；","tags":[{"name":"HTML，CSS","slug":"HTML，CSS","permalink":"http://yoursite.com/tags/HTML，CSS/"}]}]