[{"title":"标签换行产生的间距消除的三种办法及子元素继承属性问题","date":"2015-08-03T04:43:29.000Z","path":"2015/08/03/标签换行产生的间距消除的三种办法及子元素继承属性问题/","text":"消除标签间距办法 1、在父盒子设置font-size:0;自身盒子设置原来字体大小； 2、float:left; 3、直接写成一行。 子元素仅继承盒子内的文字内容属性 eg:font-size; color 、font-family …. a标签不继承","tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"【外边距塌陷】【设置浮动都会变成行内块级元素】【行内元素本身能设置内外边距】","date":"2015-08-03T04:43:29.000Z","path":"2015/08/03/【外边距塌陷】【设置浮动都会变成行内块级元素】【行内元素本身能设置内外边距】/","text":"1、两个同级元素，垂直排列，上面的盒子给margin-bottom，同时下面的盒子给margin-top,那么他们两个盒子的外边距就会重叠，以最大的那个值进行计算；2、两个父子元素，内部的盒子给margin-top，然后其父级也会受到影响，同时产生上边距,不会得到想要结果， 解决的办法1、在父级元素上添加overflow:hidden; 左右外边距不受影响 2、给父元素设置透明边框 块级元素和行内元素只要设置float，都会变成行内块级元素属性 行内元素及行内块级元素要在页面居中，需要在外层套块级元素 行内元素本身能设置内外边距","tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"浏览器渲染HTML过程（页面重构师的存在所在原因）","date":"2015-08-03T04:43:29.000Z","path":"2015/08/03/浏览器渲染HTML过程（页面重构师的存在所在原因）/","text":"WEB 页面运行在各种各样的浏览器当中，浏览器载入、渲染页面的速度直接影响着用户体验简单地说，页面渲染就是浏览器将 HTML 代码根据 CSS 定义的规则显示在浏览器窗口中的这个过程。渲染过程 用户输入网址（假设是个 HTML 页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回 HTML 文件； 浏览器开始载入 HTML 代码，发现 &lt;head&gt; 标签内有一个 &lt;link&gt; 标签引用外部 CSS 文件； 浏览器又发出 CSS 文件的请求，服务器返回这个 CSS 文件； 浏览器继续载入 HTML 中 &lt;body&gt; 部分的代码，并且 CSS 文件已经拿到手了，可以开始渲染页面了； 浏览器在代码中发现一个 &lt;img&gt; 标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码； 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码； 浏览器发现了一个包含一行 JavaScript 代码的 &lt;script&gt; 标签，赶快运行它； JavaScript 脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个 &lt;div&gt;（style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码； 终于等到了 &lt;/html&gt; 的到来，浏览器泪流满面…… 等等，还没完，用户点了一下界面中的“换肤”按钮，JavaScript 让浏览器换了一下 标签的 CSS 路径； 浏览器召集了在座的各位 &lt;div&gt;&lt;span&gt;&lt;ul&gt;&lt;li&gt; 们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。 浏览器每天就这么来来回回跑着，要知道不同的人写出来的 HTML 和 CSS 代码质量参差不齐，说不定哪天跑着跑着就挂掉了。好在这个世界还有这么一群人——页面重构工程师，平时挺不起眼，也就帮视觉设计师们切切图啊改改字，其实背地里还是干了不少实事的。 reflow（回流） 说到页面为什么会慢？那是因为浏览器要花时间、花精力去渲染，尤其是当它发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，内行称这个回退的过程叫 reflow（回流，相关链接：reflow（回流））。 reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的 变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。 当 然，reflow 问题是可以优化的，我们可以尽量减少不必要的 reflow。比如开头的例子中的 &lt;img&gt;图片载入问题，这其实就是一个可以避免的 reflow —— 给图片设置宽度和高度就可以了。这样浏览器就知道了图片的占位面积，在载入图片前就预留好了位置。 原文地址","tags":[{"name":"HTML，面试","slug":"HTML，面试","permalink":"http://yoursite.com/tags/HTML，面试/"}]},{"title":"关于CSS通配符*问题（危害）及重置写法","date":"2015-08-03T04:43:29.000Z","path":"2015/08/03/关于CSS通配符-问题（危害）及重置写法/","text":"关于CSS通配符问题 A:不知道为什么css没有哦找到 用css 通配符“”的案例呢？ Q:一般用来消除浏览器默认属性 在大多数时 候，我们需要重置浏览器元素，在dushuwu.net中介绍过很多相关的知识，但尽可能少使用全局Reset，因为不同浏览器元素的默认属性有所 不同，使用Reset可重置浏览器元素的一些默认属性，以达到浏览器的兼容。但需要注意的是，请不要使用全局Reset：*{ margin:0; padding:0; }这不仅仅因为它是缓慢和低效率的方法，而且还会导致一些不必要的元素也重置了外边距和内边距。Reset并不是一成不变的，具体还需要根据项目的不同需求做适当的修改，以达到浏览器的兼容和操作上的便利性。52CSS建议使用的Reset如下:一、清除内外边距1234567891011body, h1, h2, h3, h4, h5, h6, hr, p,blockquote, /* structural elements 结构元素 */dl, dt, dd, ul, ol, li, /* list elements 列表元素 */pre, /* text formatting elements 文本格式元素 */form, fieldset, legend, button, input, textarea, /* form elements 表单元素 */th, td, /* table elements 表格元素 */img/* img elements 图片元素 52CSS.com */&#123; border:medium none; margin: 0; padding: 0;&#125; 二、设置默认字体body,button, input, select, textarea { font: 12px/1.5 ‘宋体’,tahoma, Srial, helvetica, sans-serif;} h1, h2, h3, h4, h5, h6 { font-size: 100%; } em{font-style:normal;}三、重置列表元素 ul, ol { list-style: none; }四、重置超链接元素a { text-decoration: none; color:#333;}a:hover { text-decoration: underline; color:#F40; }五、重置图片元素img{ border:0px; vertical-align:middle;} （消除图片3px间距方法）六、重置表格元素table { border-collapse: collapse; border-spacing: 0; }","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"关于JS操作DOM的关系图","date":"2015-08-03T04:43:29.000Z","path":"2015/08/03/关于JS操作DOM的关系图/","text":"基础操作：兼容性（持续更新）: 数组及字符串的操作:","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"href和src有什么区别","date":"2015-08-03T04:43:29.000Z","path":"2015/08/03/href和src有什么区别/","text":"href和src是有区别的，而且是不能相互替换的。我们在可替换的元素上使用src，然而把href用于在涉及的文档和外部资源之间建立一个关系。href (Hypertext Reference)指定网络资源的位置，从而在当前元素或者当前文档和由当前属性定义的需要的锚点或资源之间定义一个链接或者���系。当我们写下： &lt;link href=”app.css” rel=”stylesheet” /&gt; 浏览器明白当前资源是一个样式表，页面解析不会暂停（由于浏览器需要样式规则去画或者渲染页面，渲染过程可能会被被暂停）。这与把css文件内容写在标签里不相同，因此建议使用link标签而不是@import来吧样式表导入到html文档里。 src (Source)属性仅仅 嵌入当前资源到当前文档元素定义的位置。当浏览器找到： &lt;script src=”app.js”&gt;&lt;/script&gt; 在浏览器下载，编译，执行这个文件之前页面的加载和处理会被暂停。这个过程与把js文件放到标签里类似。这也是建议把JS文件放到底部加载的原因。当然，img标签页与此类似。浏览器暂停加载直到提取和加载图像。 原文地址","tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"在sublime中，css设置snippet后缀源要写.less才生效(内附50个css代码段链接)","date":"2015-08-03T01:43:10.000Z","path":"2015/08/03/在sublime中，css设置snippet后缀源要写-less才生效-内附50个css代码段链接/","text":"如题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364ActionScript: source.actionscript.2AppleScript: source.applescriptASP: source.aspBatch FIle: source.dosbatchC#: source.csC++: source.c++Clojure: source.clojureCoffeeScript: source.coffeeCSS: source.cssD: source.dDiff: source.diffErlang: source.erlangGo: source.goGraphViz: source.dotGroovy: source.groovyHaskell: source.haskellHTML: text.html(.basic)JSP: text.html.jspJava: source.javaJava Properties: source.java-propsJava Doc: text.html.javadocJSON: source.jsonJavaScript: source.jsBibTex: source.bibtexLatex Log: text.log.latexLatex Memoir: text.tex.latex.memoirLatex: text.tex.latexLESS: source.css.lessTeX: text.texLisp: source.lispLua: source.luaMakeFile: source.makefileMarkdown: text.html.markdownMulti Markdown: text.html.markdown.multimarkdownMatlab: source.matlabObjective-C: source.objcObjective-C++: source.objc++OCaml campl4: source.camlp4.ocamlOCaml: source.ocamlOCamllex: source.ocamllexPerl: source.perlPHP: source.phpRegular Expression(python): source.regexp.pythonPython: source.pythonR Console: source.r-consoleR: source.rRuby on Rails: source.ruby.railsRuby HAML: text.hamlSQL(Ruby): source.sql.rubyRegular Expression: source.regexpRestructuredText: text.restructuredtextRuby: source.rubySASS: source.sassScala: source.scalaShell Script: source.shellSQL: source.sqlStylus: source.stylusTCL: source.tclHTML(TCL): text.html.tclPlain text: text.plainTextile: text.html.textileXML: text.xmlXSL: text.xml.xslYAML: source.yaml 原址 50个代码段链接","tags":[{"name":"sublime","slug":"sublime","permalink":"http://yoursite.com/tags/sublime/"}]},{"title":"jquery.validate.js(智能表单验证)","date":"2015-08-02T11:03:30.000Z","path":"2015/08/02/jquery-validate-js-智能表单验证/","text":"在做网页表单时时常需要在客户端对表单填写的数据进行验证一番才能提交，我们可以通过自己编写JavasScript代码来验证，但是有时数据量过多时就会有些难度了。基于jQuery的jquery.validate验证框架帮我们解决了困难，我们可以通过它迅速验证一些常见的输入,并且可以自己扩充自己的验证方法，而且对国际化也有非常好的支持。 今天记录的就是用此插件来实现表单验证，效果图： 1、获取JS文件：http://jqueryvalidation.org/，这个插件的用法就不再多讲了，如不熟悉或者还没用过的可以通过官网了解也可以搜索jquery validate中文API，此文仅仅记录如何实现上图效果。 2、导入JS12&lt;script src=\"test/jquery.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;script src=\"test/jquery.validate.js\" type=\"text/javascript\"&gt;&lt;/script&gt; 3、创建表单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;fieldset style=\"width:700px; margin:0 auto;\"&gt; &lt;legend&gt;用户注册&lt;/legend&gt; &lt;form id=\"signupForm\" method=\"get\" action=\"\"&gt; &lt;p&gt; &lt;label for=\"firstname\"&gt;用户名：&lt;/label&gt; &lt;input id=\"firstname\" name=\"firstname\" type=\"text\" /&gt; &lt;span class=\"red\"&gt;*&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"realname\"&gt;真实名：&lt;/label&gt; &lt;input id=\"realname\" name=\"realname\" type=\"text\" /&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"password\"&gt;密 码：&lt;/label&gt; &lt;input id=\"password\" name=\"password\" type=\"password\" /&gt; &lt;span class=\"red\"&gt;*&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"confirm_password\"&gt;确 认：&lt;/label&gt; &lt;input id=\"confirm_password\" name=\"confirm_password\" type=\"password\" /&gt; &lt;span class=\"red\"&gt;*&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"email\"&gt;邮 箱：&lt;/label&gt; &lt;input id=\"email\" name=\"email\" type=\"text\" /&gt; &lt;span class=\"red\"&gt;*&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"tel\"&gt;电 话：&lt;/label&gt; &lt;input id=\"tel\" name=\"tel\" type=\"text\" /&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"address\"&gt;地 址：&lt;/label&gt; &lt;input id=\"address\" name=\"address\" type=\"text\" /&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"idcard\"&gt;证件号：&lt;/label&gt; &lt;input id=\"idcard\" name=\"idcard\" type=\"text\" /&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"degree\"&gt;学 历：&lt;/label&gt; &lt;select id=\"degree\" name=\"degree\"&gt; &lt;option value=\"-1\"&gt;请选择&lt;/option&gt; &lt;option value=\"1\"&gt;小学&lt;/option&gt; &lt;option value=\"2\"&gt;中学&lt;/option&gt; &lt;option value=\"3\"&gt;大专&lt;/option&gt; &lt;option value=\"4\"&gt;本科&lt;/option&gt; &lt;option value=\"5\"&gt;学士&lt;/option&gt; &lt;option value=\"6\"&gt;硕士&lt;/option&gt; &lt;option value=\"7\"&gt;博士&lt;/option&gt; &lt;/select&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"sex\"&gt;性 别：&lt;/label&gt; &lt;input type=\"radio\" id=\"rdoFemale\" name=\"sex\" /&gt;男 &lt;input type=\"radio\" id=\"rdoMale\" name=\"sex\" /&gt;女 &lt;input type=\"radio\" id=\"rdoSecret\" name=\"sex\" /&gt;保密 &lt;/p&gt; &lt;p&gt; &lt;input id=\"read\" name=\"read\" type=\"checkbox\" /&gt;&lt;label for=\"read\"&gt;同意相关条约&lt;/label&gt; &lt;/p&gt; &lt;p&gt; &lt;input class=\"submit\" type=\"submit\" value=\"Register\"/&gt; &lt;/p&gt; &lt;/form&gt;&lt;/fieldset&gt; 4、表单初始化样式123.red&#123; color:red;&#125;.submit&#123; width:80px;&#125;input&#123;height:22px; padding:2px;&#125; 5、验证代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485$(document).ready(function() &#123; //设置默认属性 $.validator.setDefaults(&#123; submitHandler: function(form) &#123; form.submit(); &#125; &#125;), //开始验证 $(\"#signupForm\").validate(&#123; rules: &#123; firstname: &#123; required: true, stringCheck:true, byteRangeLength:[4,15] &#125;, realname: &#123; minlength:5 &#125;, password: &#123; required: true, minlength: 5 &#125;, confirm_password: &#123; required: true, minlength: 5, equalTo: \"#password\" &#125;, email: &#123; required: true, email: true &#125;, tel: &#123; isMobile: true &#125;, address: &#123; stringCheck:true, byteRangeLength:[4,100] &#125;, read: &#123; required:true &#125;, degree: &#123; required:true, min:0 &#125;, idcard: &#123; required:true, isIdCardNo:true &#125; &#125;, //设置提示信息 messages:&#123; address:&#123; stringCheck: \"请正确输入您的联系地址\", byteRangeLength: \"请详实您的联系地址以便于我们联系您\" &#125;, read:&#123; required:\"请先阅读注册条约\" &#125;, degree:&#123; min:\"请选择学历\" &#125; &#125;, //设置错误信息存放标签 errorElement: \"em\", //指定错误信息位置 errorPlacement: function (error, element) &#123; if (element.is(':radio') || element.is(':checkbox')) &#123; var eid = element.attr('name'); error.appendTo(element.parent()); &#125; else &#123; error.appendTo(element.closest(\"p\")); &#125; &#125;, //设置验证触发事件 focusInvalid: true, //设置验证成功提示格式 success:function(e) &#123; e.html(\"&amp;nbsp;\").addClass(\"valid\").text('ok'); &#125; &#125;)&#125;); 到这里表单验证功能就初步完成了，可以试着预览一下效果，点击按钮提交你肯定发现不会进行验证，因为在验证中使用了一些自定义的方法，所以验证失效，那么继续读下去吧，接下来是实现验证的提示信息的个性化和自定义验证方法。 6、我们可以知道validate默认的提示信息是英文的，我们可以编写一个jquery.validate.message_cn.js文件来改变它的提示内容并让提示内容显示成中文的：1234567891011121314151617181920212223242526//定义中文消息var cnmsg = &#123; required: \"必需填写项\", remote: \"请修正该字段\", email: \"请输入正确格式的电子邮件\", url: \"请输入合法的网址\", date: \"请输入合法的日期\", dateISO: \"请输入合法的日期 (ISO).\", number: \"请输入合法的数字\", digits: \"只能输入整数\", creditcard: \"请输入合法的信用卡号\", equalTo: \"请再次输入相同的值\", accept: \"请输入拥有合法后缀名的字符串\", maxlength: jQuery.format(\"请输入一个长度最多是 &#123;0&#125; 的字符串\"), minlength: jQuery.format(\"请输入一个长度最少是 &#123;0&#125; 的字符串\"), rangelength: jQuery.format(\"请输入一个长度介于 &#123;0&#125; 和 &#123;1&#125; 之间的字符串\"), range: jQuery.format(\"请输入一个介于 &#123;0&#125; 和 &#123;1&#125; 之间的值\"), max: jQuery.format(\"请输入一个最大为 &#123;0&#125; 的值\"), min: jQuery.format(\"请输入一个最小为 &#123;0&#125; 的值\"), //自定义验证方法的提示信息 stringCheck: \"用户名只能包括中文字、英文字母、数字和下划线\", byteRangeLength: \"用户名必须在4-15个字符之间(一个中文字算2个字符)\", isIdCardNo: \"请正确输入您的身份证号码\",&#125;;jQuery.extend(jQuery.validator.messages, cnmsg); 可以看到此文件中有一个自定义验证方法的提示信息，这些验证方法也是让之前预览没有验证效果的原凶哦，validate插件提供自定义验证方法，继续完善 jquery.validate.message_cn.js(自定义验证方法来源于网络) 文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 字符验证 jQuery.validator.addMethod(\"stringCheck\", function(value, element) &#123; return this.optional(element) || /^[\\u0391-\\uFFE5\\w]+$/.test(value); &#125;, \"只能包括中文字、英文字母、数字和下划线\"); // 中文字两个字节 jQuery.validator.addMethod(\"byteRangeLength\", function(value, element, param) &#123; var length = value.length; for(var i = 0; i &lt; value.length; i++)&#123; if(value.charCodeAt(i) &gt; 127)&#123; length++; &#125; &#125; return this.optional(element) || ( length &gt;= param[0] &amp;&amp; length &lt;= param[1] ); &#125;, \"请确保输入的值在4-15个字节之间(一个中文字算2个字节)\");// 身份证号码验证 jQuery.validator.addMethod(\"isIdCardNo\", function(value, element) &#123; return this.optional(element) || isIdCardNo(value); &#125;, \"请正确输入您的身份证号码\");/** * 身份证号码验证 */ function isIdCardNo(num) &#123; var factorArr = new Array(7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2,1); var parityBit=new Array(\"1\",\"0\",\"X\",\"9\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\"); var varArray = new Array(); var intValue; var lngProduct = 0; var intCheckDigit; var intStrLen = num.length; var idNumber = num; // initialize if ((intStrLen != 15) &amp;&amp; (intStrLen != 18)) &#123; return false; &#125; // check and set value for(i=0;i&lt;intStrLen;i++) &#123; varArray[i] = idNumber.charAt(i); if ((varArray[i] &lt; '0' || varArray[i] &gt; '9') &amp;&amp; (i != 17)) &#123; return false; &#125; else if (i &lt; 17) &#123; varArray[i] = varArray[i] * factorArr[i]; &#125; &#125; if (intStrLen == 18) &#123; //check date var date8 = idNumber.substring(6,14); if (isDate8(date8) == false) &#123; return false; &#125; // calculate the sum of the products for(i=0;i&lt;17;i++) &#123; lngProduct = lngProduct + varArray[i]; &#125; // calculate the check digit intCheckDigit = parityBit[lngProduct % 11]; // check last digit if (varArray[17] != intCheckDigit) &#123; return false; &#125; &#125; else&#123; //length is 15 //check date var date6 = idNumber.substring(6,12); if (isDate6(date6) == false) &#123; return false; &#125; &#125; return true; &#125; 在文件中导入jquery.validate.message_cn.js文件1&lt;script src=\"test/jquery.validate.message_cn.js\" type=\"text/javascript\"&gt;&lt;/script&gt; 到这里表单的验证功能就做好了，现在预览的效果应该是这样的： 如果没是这样的效果那要好好看看是不是漏了哪一步呢？还有最后一步就是编写验证样式来实现个性化验证，那个正确（’√’）和错误（’×’）的提示是背景图片，我们可以从网上找到自己中意的小图标就行了，验证样式为： 1234567891011121314151617181920212223242526272829/** * @DO 校验的样式文件 * @DATE 2010-11-25 * @AUTHOR Frylan */ /*错误样式*/input.error &#123; border: 1px dashed red;background:yellow; padding:2px; &#125;select.error &#123; border: 1px dashed red; background:yellow; padding:2px; &#125;.error &#123; padding-left: 16px; margin-left: 2px; color:red; /*背景图片（校验未通过的’×’图标）*/ background: url(unchecked.gif) no-repeat 0px 0px; font-family:Verdana, Geneva, sans-serif; font-size:11px;&#125;/*验证通过样式*/input.valid&#123; background:#FFC; border:#09F solid 1px; padding:2px;&#125;select.valid&#123; background:#FFC; border:#09F solid 1px; padding:2px;&#125;.valid &#123; padding-left: 16px; margin-left: 2px; /*背景图片(校验通过的’√’图标)*/ background: url(checked.gif) no-repeat 0px 0px; font-family:Verdana, Geneva, sans-serif; color:#00F; font-size:11px;&#125; 当然这个只是我这个效果的样式，表单和验证样式都可以根据自己的喜好来设置。这些都做完之后再次预览就应该是文中开头那个的效果图片了。","tags":[{"name":"插件","slug":"插件","permalink":"http://yoursite.com/tags/插件/"}]},{"title":"背景图由中点开始放大方法","date":"2015-07-02T04:43:29.000Z","path":"2015/07/02/背景图由中点开始放大方法/","text":"如题12345678910111213141516171819202122232425&lt;style&gt; body &#123; background-color: #F2F2F2; &#125; .zoom &#123; width: 300px; height: 300px; border: 1px solid #CCC; margin: 100px auto; background-image: url(./images/bg.jpg); background-position: center; background-size: 100% auto; position: relative; transition: all 1.5s; &#125; .zoom:hover &#123; background-size: 120% auto; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"zoom\"&gt;&lt;/div&gt;&lt;/body&gt;","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"jquery实现图片无缝轮播显示（面试笔试有用）","date":"2015-03-19T18:43:29.000Z","path":"2015/03/20/浏览器调试工具修改代码直接关联到文件并修改-add-folder-to-workspace/","text":"添加文件夹到 workspace添加好后，右键一个文件，选择「Map to file system resource…」，在弹出的文本框中选择在 Workspace 中对应的文件： 添加映射文件 选择对应的本地文件比如我映射了 style.min.css 文件，那么现在你编辑元素面板中的样式，Chrome 就会实时保存本地的文件变更。 具体的文件映射规则可以到 Devtools &gt; Settings &gt; Workspace 中设置： PS: 如果你映射的是文件夹，像 all.js?v=4.1 之类带参数的请求是无法映射的。 参考资料","tags":[{"name":"调试工具","slug":"调试工具","permalink":"http://yoursite.com/tags/调试工具/"}]},{"title":"jquery实现图片无缝轮播显示（面试笔试有用）","date":"2015-03-15T13:43:29.000Z","path":"2015/03/15/jquery实现图片无缝轮播显示/","text":"克隆图片案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;图片无缝轮播显示&lt;/title&gt;&lt;script type=\"text/javascript\" src=\"./jquery.js\"&gt;&lt;/script&gt;&lt;style&gt; .box,.box2&#123; width:800px; height:260px; margin:160px auto; overflow:hidden; position:relative;&#125; .box,.box2 p&#123; text-align:center;&#125; .picBox,.picBox2&#123; margin:0px; padding:0px; list-style:none; width:1500px;&#125; /* &lt;!--此处很关键，在实现无疑轮播时这个宽度一定要比显示图片数量+1的宽度宽--&gt; */ .picBox:hover,.picBox2:hover&#123; cursor:pointer;&#125; .picBox li,.picBox2 li&#123; float:left;&#125; .picBox img,.picBox2 img&#123; width:200px; height:240px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt; &lt;p&gt;第一种图片轮播：非无缝轮播&lt;/p&gt; &lt;ul class=\"picBox\"&gt; &lt;li&gt;&lt;img src=\"images/1.jpg\"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/2.jpg\"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/3.jpg\"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/4.jpg\"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/5.jpg\"/&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"box2\"&gt; &lt;p&gt;第二种图片轮播：无缝轮播&lt;/p&gt; &lt;ul class=\"picBox2\"&gt; &lt;li&gt;&lt;img src=\"images/1.jpg\"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/2.jpg\"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/3.jpg\"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/4.jpg\"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/5.jpg\"/&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;script&gt; $(function()&#123; // &lt;!--第一种图片轮播：非无缝轮播--&gt; function rollOne()&#123; $(\".picBox li:first\").animate(&#123;left:\"-=200px\"&#125;,\"linear\",function()&#123; $(this).remove().clone(true).appendTo(\".picBox\").fadeIn(\"slow\"); &#125;); &#125; var startRollOne=setInterval(rollOne,2000); // &lt;!--鼠标移入停止移出继续--&gt; $(\".box\").hover(function()&#123; clearInterval(startRollOne); &#125;,function()&#123; startRollOne=setInterval(rollOne,2000); &#125;); // &lt;!--第二种图片轮播：无缝轮播--&gt; // &lt;!--这种无缝轮播可以通过设置animate动画播放速度值和setInterval中的函数调用时间间隔实现间隔无缝轮播--&gt; function rollTwo()&#123; $(\".picBox2\").animate(&#123;marginLeft:\"-200px\"&#125;,2000,\"linear\",function()&#123; $(\".picBox2\").css(&#123;marginLeft:\"0px\"&#125;); $(\".picBox2 li:first\").remove().clone(true).appendTo(\".picBox2\"); &#125;) &#125; var startRollTwo=setInterval(rollTwo,2000); // &lt;!--鼠标移入停止移出继续--&gt; $(\".picBox2\").hover(function()&#123; clearInterval(startRollTwo); &#125;,function()&#123; startRollTwo=setInterval(rollTwo,2000); &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"jQ轮播图","slug":"jQ轮播图","permalink":"http://yoursite.com/tags/jQ轮播图/"}]},{"title":"jQuery记忆与问题（面试笔试有用）","date":"2015-03-15T01:43:29.000Z","path":"2015/03/15/jQuery记忆与问题/","text":"【jQuery操作一定要做变量本地化】（功能强大，必定效率不高）1、本地化的意思是把 var dom = $(“dom”);这样就是变量本地化（这样做原因是，$的属性方法很多，效率不高，本地化就是提高效率）【入口函数】1、JQ入口函数，是在页面dom元素加载完毕后就开始加载JS入口函数等页面全部加载完再加载（包括图片）【width()和innerWidth()】1、.width() 只能获取内容的宽度2、.innerWidth（）获取包括padding内的宽度不包括边框3、.outerWidth() 获取包括border在内的宽度，不包括margin4、.outerWidth(true) 获取包括margin在内的宽度【jq的offset().left】1、jq的offset().left获取离窗口的左边距，与有定位父级无关 和JS不同 【.children(“p”)和.find(“p”)】1、都可以寻找后代，但find能找后代的后代，children不能 【$(“li:gt(2):lt(9)”)】1、这里意思是 从第3个Li 选择 到第13个li 连写后面的lt是代表 从第三个开始角标为0计算 【end()和addBack()】1、 .end() 选择前一级的元素2、 .addBack() 选择前面所有的元素 【$.trim(str)】1、 清除字符串里面的空格 【清除冒泡或清除默认事件】1、return false // 不能清除冒泡，只能清除默认事件2、event.stopPropagation() //清除冒泡3、event.preventDefault // 不能清除冒泡，只能清除默认事件4、JQ triggleHandler() // 清除冒泡，清除默认事件 【表单序列化】（当表单用JQ的ajax方法）1、data : $(&#39;#my_form&#39;).serialize(); （前提:表单input里面的name要与php文件里面的参数(.GET(“name”))要一致） 【remove()和empty()】1、$(“ul”).remove(); 直接删除ul节点2、$(“ul”).empty(); 删除ul里面所有内容，不包括ul 【$(window)】1、 window不用双引号 【delete】（JS的方法）（案例看jq的备忘录删除功能）1、delete删除掉数组中的元素后，会把该下标出的值为undefined，数组的长度不会变 【continue】1、jQ里面的$.each()方法不能使用continue;只能用原始的for循环才能使用 【普通事件和委托事件】1、obj.click() 和 parent .on(“click”,obj,function(){}) 当用JS动态创建的dom元素就必须用委托on去绑定事件 其余都用.click(); 【data】eg: &lt;li data-xxx=&quot;xxxxx&quot;&gt;aaa&lt;/li&gt; (这里aaa是展现，xxxxx是跟这个li相关的数据)1、 自定义属性data- * 通过DOM存储于DOM对象强相关的数据2、 JS源生获取data dom.dataset[“xxx”];3、 JQ $(“obj”).data(“xxx”); 【备忘录学习地方】(JQ备忘录)1、store插件的使用 store.set(“arr1”,arr) store.get(“arr1”) store.clear(); store能保存本地数据，下次刷新的时候数组不会清空 **每次更改数组内容 都要更新store.set(“arr1”); 因为store存储的数据会根据浏览器自动选择使用 localStorage、globalStorage 或者 userData 来实现本地存储功能。 2、通过{}创建对象作为备忘录项，并添加到数组里 3、delete删除掉数组中的元素后，会把该下标出的值为undefined，数组的长度不会变,原本的下标不会改变 4、continue:jQ里面的$.each()方法不能使用continue;只能用原始的for循环才能使用 5、$.trim(str) 6、时间戳 (new Date()).getTime() 7、jq获取日期时间的插件 【$.extend】(写JQ插件的)(JQ)1、原理 $.extend(json1,json2); 如果2者有相同属性，json2会覆盖json1的该属性 2、写插件要写css 和 js 2个文件 3、js 默认样式123456(function($)&#123; $.fn.extend(&#123; myFn : function()&#123;&#125; &#125;) &#125; )(jQuery) 4、日后写框架，用闭包更安全123var initTab = (function($)&#123; function init()&#123;&#125; return init;&#125;)(jQuery)initTab(); //return","tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"JS基础笔记（面试笔试有用）","date":"2014-12-15T12:43:29.000Z","path":"2014/12/15/JS进阶/","text":"【定义@keyframes】1、 0% { opacity: 0;} 100% { opacity: 1;} *千万别在后面家逗号或者分号【html,body】1、html,body { width:100%; height:100%;}为什么这样写，是因为有些浏览器body高度并不是占满页面，这样设置保证body得到全屏宽高（做整屏动画要考虑） 【document.body.offsetHeight和document.body.clientHeight】1、前者获取body标签高度，后者获取窗口（视口）高度,两者不一样 如果body不设置高度，前者会等于0，后者等于视口宽度 2、document.body.offsetWidth 获取到的是包括滚动条的宽度 反而document.body.clientWidth 不包括滚动条 【防止拖动时选中内容】1、window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty(); 2、直接在函数体最后return false; 【js单引号双引号问题】1、Json 里如果要用引号，建议使用双引号，这样别的语言也能识别数据 2、JS为什么要用单引号，是因为JS都把内容或者样式插入行内，标签属性定义时一般用双引号，JS赋值的时候用单引号，不容易出错 【直接改变数组的值】1、123var arr = [1,3,5,6];arr[3] += 1;console.log(arr); // [1,3,5,7] 【转换标准json格式的网站】1、bejson网址 【Math.min.apply(null,arr)】1、这是一种获取数组里面最小数的一种方法，是通过function.apply(this,arguments)，反之取大值就改变前面的方法Math.max **apply详情可以查看 【冒泡事件注意事项】1、冒泡事件只能禁止同类型事件1234567btn.onclick = function(e)&#123; e.stopPropagation(); console.log(1);&#125;wrap.onmousedown = function()&#123; console.log(2); // 打印 2 1&#125; 2、爷父子三个盒子，如果在父盒子中阻止冒泡事件，那么子盒子也不会冒泡到爷盒子上，只会冒泡到父盒子上 3、父盒子绑定事件，子盒子没有绑定事件（子盒子有宽高），如onmouseover，在父盒子和子盒子来回移动会不断触发事件发生， 如onclick(1218自己做的登录窗口点击消失案例中，点击box里面的有高度的hd盒子也会消失，移动的时候前提要先onmousedown触发，如果不能触发可能是点击事件冒泡有影响) 这是子盒子的冒泡事件，解决办法在父盒子设置计数器，当触发的时候等于1，大于1的时候不在触发 【document.body.scrollTop能读值取值】1、document.body.scrollTop能被赋值 【this】（面试） 0、只要有闭包事件，它的调用者就是window,this就指向window，没有任何特殊情况 *如果this指向undefined1、this: this所在的函数在哪个对象中，this就指向对象（大部分情况） eg:123456function dog()&#123;console.log(this); &#125; dog(); //this指向window，因为所有的全局变量和所有的函数都是window的属性和方法 new dog() //this指向dog，new 关键字可以让 this 指向新的对象，这就是所谓的构造函数 2、少数情况特殊: （1） 如果this在定时器中, this就指向window （2） 如果this在事件源中, this就指向产生这个事件源的对象 **解决方法用备份指针 var self = this; 【构造函数的prototype】(面试)1、是为了共享属性和方法，不用的话，每一个构造函数的实例都会各自创建新的方法，会消耗内存，如果用了原型，就会让所有的实例共用这个方法，只开辟 一次内存 【;(function(){})()】1、;为了防止前一个封闭作用于没有小括号导致后面的闭包变成实参 【H5新标签】 1、seletor.classList.add(&quot;class&quot;);2、seletor.classList.toggle();","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"JS基础笔记（面试笔试有用）","date":"2014-12-15T12:43:29.000Z","path":"2014/12/15/AJAX笔记/","text":"【AJAX标准写法】(记忆)1234567891011121314151617181920// 创建xhrif(window.XMLHttpRequest)&#123; // 5种判断方式（window,typeof,try-catch,in,判断浏览器） var xhr = new XMLHttpRequest();&#125; else &#123; var xhr = new ActiveXObject(\"Microsoft.XMLHTTP\");&#125;// 连接xhr.open(\"get\",url,true);// 发送xhr.send();// 接收xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304)&#123; alert(xhr.responseText); // 返回文本内容 &#125; else &#123; alert(xhr.status) // 如果前面有错误则返回404 &#125; &#125;&#125; 【jsonp封装注意地方】(url,data,cbName,success,error,timeout)1234567891011121314151617181920212223242526272829303132333435363738394041function jsonp(options)&#123; options = options || &#123;&#125;; if(!options.url) return; options.data = options.data || &#123;&#125;; options.cbName = options.cbName || \"cb\"; // 不同的搜索引擎的回调函数不一样 百度 \"cb\" 360 \"callback\" options.timeout = options.timeout || 0; var fnName = (\"jsonp_\" + Math.random()).replace(\".\",\"\"); // 给回调函数添加随机因子 var arr = []; options.data[options.cbName] = fnName; // 添加回调函数 for(var name in options.data)&#123; arr.push(name + \"=\" + encodeURIComponent(options.data[name])); &#125; var str = arr.join(\"&amp;\"); //2 全局函数 window[fnName] = function(json)&#123; // window[fnName]为全局函数，局部函数声明全局变量用window好维护 // 这里的json，是fnName这个回调函数返回过来的数据（默认） options.success &amp;&amp; options.success(json); window[fnName] = null; // 把函数清空，释放内存，减少浏览器性能的消耗 oHead.removeChild(oS); // 每次调用全局函数，清除head头里面的script标签 clearTimeout(timer); &#125;; //1 创建script var oS = document.createElement(\"script\"); oS.src = options.url + \"?\" + str; var oHead = document.getElementsByTagName(\"head\")[0]; oHead.appendChild(oS); if(options.timeout)&#123; var timer = setTimeout(function()&#123; options.error &amp;&amp; options.error(); window[fnName] = function()&#123;&#125;; // 接受超时，要把全局函数赋值为空函数，不然会报错 oHead.removeChild(oS); &#125;,options.timeout); &#125;&#125; 【ajax的上传方式get post】1、 get : 有缓存 post : 没缓存（相对安全，信息不会暴露在地址栏） 【表单】(刷新整个页面)1、表单三要素 （一）action:地址 （二）name:上传的名字 （三）value:上传的值 2、method ——— get: 数据在地址栏上显示 不安全 32K post: 数据隐藏 相对安全 1G 【缓存问题】1、缓存： 浏览器对同一个的地址只会访问一次，再次加载也是重新记录上一次的东西 （IE缓存严重） 解决： 让地址不一样 ———————–（1）添加随机数 t=Math.random(); ———————–（2）时间戳 new Date().getTime(); 【try catch】(一般不用，性能差)1、12345try&#123;// 可能出错代码&#125; catch(e)&#123;// 补救代码&#125; catch里的e参数 必须有，获取报错信息 【typeof特殊用法】12.221、12console.log(a) // 报错console.log(typeof a); // 返回undefine，但不报错*用于兼容判断IE，不报错2、（面试）1console.log(typeof (typeof a)) // string【后台文件传过来的json的一些注意事项】1、后台传输过来的数据一定是string类型，如果要通过JS接收后台数据就要转换指定的类型 eval(‘(‘+json+’)’); (jq方法接收数据不能用eval，不然会报错) JSON.parse(json字符串)2、AJAX解析后台资源，通过JSON.parse（）转换 等同于 eval(&quot;(&quot;+json+&quot;)&quot;)，后者动态函数，要做赋值操作，不然报错;json转string】 2、JSON.stringify(json); (固定写法)但不兼容IE 6 7json转num】 3、eval(&#39;(&#39;+json+&#39;)&#39;); // 因为json是大括号包着，但有大括号系统会去寻找上边的是否缺少东西如是否缺少for function if等语句，会报错 // 所以要在json外面添加（json）json标准格式】 4、 属性名必须是双引号，值如果是字符串也要双引号，但如果要用单引号的话，外面要用转义字符/‘abc/‘【undefined 和 not defined】1、undefined是JavaScript语言中定义的五个原始类中的一个，换句话说，undefined并不是程序报错，而是程序允许的一个值。not defined是javascript在运行我们的javascript代码时，遇到没有定义就用来运算的变量或者变量是个方法时报出来的错误。【编码方式】1、编码 encodeURIComponent(&#39;str&#39;)&#39; 中文编码成ASCII码1、解码 decodeURIComponent(&#39;%21%323%234&#39;)&#39;地址栏里面只能是ASCII编码组成，如果有中文要进行编码操作【HTTP状态码】 三个数字组成 第一位代表类型1XX 请求已经接受，正在处理2XX 成功3XX 重定向 （3以内只有304成功（第二次打开浏览器，会把自己第一次的缓存与服务器相关的东西的最后修改时间进行对比，如果相等就返回304））4XX 错误 ———&gt;前台错误5XX 服务器错误 ———&gt;后台错误 （503错误，服务器超载，内存被塞满，例子：12306太大访问量，就会出现503错误）【eval】1、标准格式 eval(&quot;(&quot;+str+&quot;)&quot;)【replace】1、字符串替换 str.replace(&quot;被替换的字符串&quot;，&quot;替换者&quot;)【80端口】1、所有网页都默认是80端口【jsonp】1、JSONP(JSON with Padding)是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。写法：1、创建一个script标签2、定义一个全局函数跨域:只要域名 端口 协议任意一个不同就算跨域 （后台不存在跨域问题，只有前台）前端跨域时，数据必须有名接受，没名字的数据前端拿不了，只能通过后台中转网址的组成: http:// www .520it .com :80 /index.html 协议 二级域名 一级域名 域名后缀 端口 资源地址ajax跨域解决方法（逐步深入理解跨域实现原理）1. Script的src方式加载js文件（script可以引入任意的文件(通过script引入地址的方式获取其他服务器上的信息)）2. 加载的js文件内进行函数调用3. 数据以函数参数的形式传递4. 回调函数中获取参数数据（回调函数就是下面的show把json的东西返回给页面）https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=aaa&amp;cb=showwd: word 关键字cb: callback 回调函数img标签的src不用通过appendChild() 就可以访问src地址script等其他标签 都不能 必须添加【ajax与jsonp是两回事】 【window a】1、在局部函数内定义全局变量 用window去定义，在局部函数里这样写容易维护 (前提要调用局部函数，才会产生全局变量) 2、 eg123456function a()&#123; var b = 3; var 一直为局部变量 console.log(b);&#125;a(); console.log(b); //最后打印1,然后报错 123456function a()&#123; window.b = 3; window.b 要调用后才能为全局变量 console.log(b);&#125;a(); console.log(b); //最后打印1,1 1234567function a()&#123; window.b = 3; window.b 要调用后才能为全局变量 console.log(b);&#125;console.log(b);a(); console.log(b); //最后报错 【绑定】(绑定多个事件)（false：代表冒泡 true：代表捕获 （浏览器事件流就是指冒泡，捕获））1、obj.addEventListener(“事件名”，函数,false) // IE 9+ eg: document.addEventListener(&quot;click&quot;,fn,false); 2、obj.attachEvent(&quot;onclick&quot;,fn) // IE 6 7 8 【网络延时】（onload 是 window img script的属性）1、可以用obj.onload方法去包裹需要服务器返回的数据，但不兼容IE (“onload” in obj) 判断兼容方法 IE用obj.onreadystatechange 2、因为JS是先加载页面的标签和图片后再执行 JS代码， 如果window.onload = function(){ img.onload = function(){console.log(1);}}; *不会读取到console.log(1); 【浏览器默认行为与绑定解绑事件的混合使用】1、event.preventDefault 和 return false 都可以取消默认行为 【事件委托】（提高效率，不用循环多次）1、原理：冒泡 （给对做事件的元素的最大父亲添加对应事件,点击子元素弹出指定元素）event.srcElement 兼容chrome ieevent.target 兼容chrome oz var oSrc = event.srcElement || event.target 【target事件和currentTarget】（看事件委托内含高级排他）1、target在事件流的目标阶段；currentTarget在事件流的捕获，目标及冒泡阶段。只有当事件流处在目标阶段的时候， 两个的指向才是一样的， 而当处于捕获和冒泡阶段的时候，target指向被单击的对象而currentTarget指向当前事件活动的对象（一般为父级）。 2、target.id 、 target.tagName eg:123456789ul.onclick = function(e)&#123; var e = e || event; var oSrc = e.target; var oSrcTagName = e.target.tagName; console.log(e.target.tagName) // 返回点击元素的标签名 console.log(e.target) // 指点击的元素 console.log(e.currentTarget); // 指ul&#125; 【AJAX是在浏览器和服务器之间架一层AJAX引擎作过滤，筛选】","tags":[{"name":"ajax","slug":"ajax","permalink":"http://yoursite.com/tags/ajax/"},{"name":"jsonp","slug":"jsonp","permalink":"http://yoursite.com/tags/jsonp/"}]},{"title":"JS基础笔记（面试笔试有用）","date":"2014-12-11T10:23:29.000Z","path":"2014/12/11/JS基础笔记（面试笔试有用）/","text":"【if判断‘=’和‘==’问题】千万记着以后都写双等于去判断1、if( i = 0)和if( i == 0)第一个是赋值操作判断语句(这样写容易进入死循环除非是true和false的情况) 第二个才是正常情况 【for循环的】1、先声明变量 后判断终止条件 再执行括号内容 最后++i2、对于for循环 i++和++i都可以使用，++i的内存应用效率更高，在转化成汇编语言的时候，会少开辟一个变量 【字符相加和相减的类型变化】1、5 + ‘8’ 和 ‘5’+‘8’打印结果为58(最终都转换为string类型) 5 + 8 =13 num 类型2、‘8’ - 5 和 ‘8’ - ‘5’ 和 8 - 5 打印结果都为3（最终都转换为num类型）3、 ‘asd’ - ‘zcx’ 打印结果未NaN(最终结果为num类型) 【释放内存和销毁变量】1、函数调用完后，立即销毁函数内的局部变量 【style和script的位置】1、style样式一般写在里面，但实际上可以写在body里面或者其他位置，但这就会涉及到浏览器渲染顺序问题，style标签写在body里CSS会重新渲染一次页面，占用一定时间，如果网页篇幅少的话感觉不出来，如果篇幅多（大量HTML）会有一定的影响，所以大页面中不建议将style写进body（就像一些电商网站，有部分CSS写在body里面，这是为了方便修改源代码，否则你还得去翻CSS比如网站左侧、右侧的广告模块，很多页面都要加入这个广告，所以他就把广告这一块的html写到一个文件里，然后在加载过来。所以css也和他写在一起。） 【淘宝搜索框 oninput&amp;&amp;onpropertychange】1、 打字label文字就消失，清空文字就显示原本的label文字12345678910111213141516window.onload = function()&#123; function $(id)&#123;return document.getElementById(id);&#125; //oninput 大部分浏览器支持 检测用户表单输入内容 //onpropertychange ie678 检测用户表单输入内容 $(\"txt\").oninput = $(\"txt\").onpropertychange = function()&#123; if(this.value == \" \") &#123; $(\"message\").style.display = \"block\"; &#125; else &#123; $(\"message\").style.display = \"none\"; &#125; &#125;&#125; 2、&lt;input type=”text” placeholder=”必败的国际大牌” 同样得到上面的效果 placeholder是H5 input的新属性 这2种写法避免多重判断光标位置，是否打字等， 【算法、关系、逻辑运算符的关系】1、逻辑运算符（!,&amp;&amp;,||）与操作：egvar result=true&amp;&amp;3 //3var result=1&amp;&amp;3 //3var result=false&amp;&amp;3//falsevar result=””&amp;&amp;3 //“” (前面根据booler类型决定 true就取最后一个true的值 false就取false的值) 或操作：如果第一个值为真则结束后面的判断 （true就取第一个true的值 false就取最后一个false的值) 2、优先级—————-算术运算符》关系运算符》逻辑运算符 运算符顺序 1 () 2 !、-、++、– (-10) 负号 正号 3 *、/、% 4 +、- 10-5 5 &lt;、&lt;=、&lt;、&gt;= 6 ==、!=、===、!==、 7 &amp;&amp; 8 || 9?: 10 =、+=、-=、*=、/=、%= 赋值 【window.getComputedStyle(“元素”, “伪类”)[attr]】（伪类位置默认为null）1、获取一个元素的属性集合用法：getComputeStyle(element,null).width 优点：解决obj,style[attr]只能去行内样式的缺陷 缺点：因为要得到全部属性集合才能取想要的值，所以是非常耗内存的操作 【eval】（一般不用，以防面试会问）1、eval方法是开启程序解析器的入口，对于js程序来说，当程序运行的时候，会开启一次程序解析器，会解析对应的代码，当我们 使用eval函数的时候会再次开启程序解析器，会解析eval中的内容2、可以用来让浏览器自己识别简单的算法运算并得出结果 3、eval原理 去掉字符串的冒号，变成非string类型 【JS的数组和别的语言数组最大区别】1、JS同一个数组能同时存放不同的数据类型，别的语言只能存贮相同类型的数据类型 【全选与反选得出的取反思想】1、123456btns[1].onclick = function () &#123; for(var i =0;i &lt;inputs.length;i ++)&#123; //左边的设置值，右边的是取值 inputs[i].checked = !inputs[i].checked; &#125;&#125; 这种方法一般是控制dom元素的属性值，！这里是关键，因为一般属性判断只有2个值true 和 false，用这种方法会比较简洁; 【window.location.href】1、页面跳转方法 【定时器的本质】1、Interval定时器：在外设置1s间隔循环一次，如果里面的程序需要2s才能运行完毕，那么最终时间2s （一个定时器，外面设置间隔时间，里面也有执行时间，最终时间按长的时间计算）2、TimeOut定时器：间隔时间+程序执行时间 = 最终时间； 这里涉及队列问题，有异步的思想在里面，原理是定时器的运作会与定时器里面的程序同时启动，如定时器间隔1s运行1次，里面程序2秒才能执行完程序，那么定时器会与里面程序同时执行（异步）当定时器1s过完后，必须要等待里面程序执行完毕才能执行下一次定时器循环，而这里由于定时器的1s已经完成，所以下一次循环会立刻开启 3、函数声明放在定时器外面，能提高效率，避免每一次定时器循环都声明变量开辟新的内存，这样会耗用性能 【元素的类型判断nodeType】1、nodeType = 1 为元素节点2、nodeType = 2 为属性节点3、nodeType = 3 为文本节点 4、用法** （可以在循环内判断nodeType类型去添加不同节点类型） 【array.srot()】（面试可能会问）1、sort（）原理是通过ascII编码顺序去排列，是按照数组的值的首字母或者首位数字去进行由大到小排列，所以是不精准的 如果需要按顺序由大到小或者小到大完整排列，必须在sort()括号里添加一个参数去判断比较a,b值大小， * 详情查看W3C 【document.body】1、如果在用 document.body.appendChild(); 生成的元素会插在的后边 (原因是浏览器解析的时候会把标签放到body内) 【innerHTML和value】1、获取文本，&lt;input&gt;和&lt;textarea&gt; 必须用.value 【offsetLeft的位置】1、offsetLeft是相对于有定位(无论相对定位还是绝对定位)的父盒子(offsetParent) 没有就找body去找位置 【json的一些注意事项】1、json是无序的，不能用下标去表示2、访问里面的值，可以用点语法，也可以用[]如果用json[‘key’] 那么json里面的键值对的键可以用引号也可以不用引号都能获取 如果用json.key 怎么取值都能获取,但不能写成json.’key’; 3、反正想着获取的key值 是否是字符串就可以选择相对应的方法 【抽取工具类的原因】（面试）1、提高代码扩展性，可以举 12.7最后一个例子 json—-myfn的例子去解释 （是一个由获取id tagname 到 for循环的抽取例子） 这个封装的each方法，只是作了声明 和 调用 ，所以赋值在调用each的时候才真正完成一个函数的调用 【右键事件】1、document.oncontextmenu = function(e){} document是最大的事件源e是事件源 兼容ie的方法 var e = e || event; 2、return false;能清空默认右键事件并且不影响自定义事件 【e.currentTarget】1、用来获取当前的事件源是谁 类似于this 【for循环的另一种写法】（思想一致）（遍历最里层盒子到页面边的距离）1、123456var box2 = document.getElementsByTagName('div')[2];var sum = 0;for( var i = box2; i.offsetParent; i = i.offsetParent)&#123; sum += i.offsetLeft + i.offsetParent.clientLeft;&#125;console.log(sum); 【offset和client前缀】1、offsetWidth,offsetHeight 是 content + padding + border 的距离 ** document.body.offsetHeight 获取标签高度 offsetLeft,offsetTop 是到最近的有定位的父级的距离（不包含该父级的边框） 2、clientWidth,clientHeight 是 content + padding 的距离 * document.body.clientHeight 获取页面视口高度（与上面不一样） clientLeft,clientTop 是该元素border的厚度 3、parentNode和offsetParent parentNode是找父盒子（最深找到HTML标签） offsetParent是找有定位的父盒子（最深只找到body标签） 【获取屏幕分辨率（就是显示屏的）】1、window.screen.width / window.screen.height 【闭包的原理】1、闭包的作用:延长局部变量的生命周期 （同时，弊端就会大量占用内存） 2、需求1:想要在函数外面（另外一个函数中）访问某一个函数内部的局部变量 【for循环内部的一些原理】1、在for循环遍历按钮时，如果要在按钮输出变量i，会得到最后的i值，这是因为按钮、定时器等都是延时操作，只要有延时操作最终输出的变量都是i值，因为在按钮点击或者触发定时器的时候外层的for循环已经完成。（基本我接触到的里面任何函数操作都是延时操作,除了闭包) eg:12345678var div = document.getElementsByTagName('div');for( var i = 0; i &lt; div.length; ++i)&#123; (function(a)&#123; div[i].onmouseover = function()&#123; console.log(a); &#125; &#125;)(i)&#125; **这里闭包里面的div[i] 为什么能获取i的值，就是因为外面的闭包不是延时操作，所以可以遍历所有的div; 【btn.onclick = function(){}】1、为什么这里的匿名函数funtion(){} 不能传入普通参数进行操作，是因为这里的参数是代表前面btn的onclick事件源， btn.onclick = function(a){ console.log(a); //返回ClickEvent{} （代表事件源） } btn.onclick 等于号后面是一个函数体，要有click出发才会执行，所有不应该有小括号立即调用，所以也不存在有普通参数传递的原因，但事件参数a会一直存在 【字符操作】1、（获取数字） indexOf(‘string’) 括号里放获取位置的字符 从左向右顺序，没有该字符就返回-1； else:(lastIndexOF(‘strinig’)) 从右向左找，但返回的数字也是从左向右 2、（获取字符） charAt() 括号里放对应字符的位置去获取相应字符3、 charCodeAt() 去对应字符的Unicode编码 普通编码‘0-127编号’ 中文的编码是大于127 而且中文占2个字符的位置**Unicode和askcII 【ClientY和PageY（不兼容IE）】1、e.ClientY 只能获取视觉上的页面顶部2、e.PageY 获取页面最顶部，不管是否有滚动条 【for里面定义的变量是全局变量】1、for里面定义的变量是全局变量 2、var a = 1; var a = 2; //第二个var被自动忽略 console.log(a); //2**JS容错率很高，当检测到第一个var a的时候会向内存开辟一个空间，后边的重复声明a都会自动忽略var 这是引擎处理程序问题，要了解要自己百度【透明度兼容】1、opacity: 0.4; W3C浏览器2、filter: alpha(opacity:40); 兼容IE","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"HTML5项目笔记","date":"2014-12-10T04:20:29.000Z","path":"2014/12/10/HTML5项目笔记/","text":"【webstrom快捷键】1、Ctrl + “+/-“ 收缩标签2、Ctrl+Shift + “+/-“ 收缩全部标签3、Ctrl+Alt+L 自动格式化 全套快捷键在HTML5项目里的doc文件 【字体图标】1、以后用阿里云的字体库，阿里云有unicode编码*2、由于google浏览器设置的最低font-size是12px，要改变字体图标大小，添加inline-block，之后再进行-webkit-transform: scale(0.7)进行缩放","tags":[{"name":"HTML，CSS，WebStrome","slug":"HTML，CSS，WebStrome","permalink":"http://yoursite.com/tags/HTML，CSS，WebStrome/"}]},{"title":"HTML+CSS笔记","date":"2014-12-08T04:20:29.000Z","path":"2014/12/08/HTML+CSS笔记/","text":"【清除浮动】1、父盒子给高度2、父盒子给overflow: hidden;3、在同级元素尾部添加标签并增加样式 clear: both;【表单】1、所有具有功能的标签（input,select…）都要放在form表单中才能生效2、1234567&lt;form&gt; &lt;fieldset&gt; &lt;legend&gt;用户注册&lt;/legend&gt; &lt;input type=\"text\"&gt; ....... &lt;/fieldset&gt;&lt;/form&gt;fieldset和legend能使一个边框上有文字生成，一种格式。【dl&gt;dt+dd】1、图文混排就想到 dt+dd 增强语义化 （float:left;）【figure标签】1、语义化媒体标签1234&lt;figure&gt; &lt;figcaption&gt;&lt;/figcaption&gt; &lt;div&gt;&lt;/div&gt;&lt;/figure&gt;【datalist】1、数据绑定123456789101112131415&lt;input id=\"myCar\" list=\"cars\" /&gt;&lt;datalist id=\"cars\"&gt; &lt;option value=\"BMW\"&gt; &lt;option value=\"Ford\"&gt; &lt;option value=\"Volvo\"&gt;&lt;/datalist&gt;``` 【details】1、被折叠的内容 像二级树``` HTML&lt;details&gt; &lt;summary&gt;打开&lt;/summary&gt; 打开的内容&lt;details&gt;【marquee】（类似弹幕）1、滚动的标签（W3C没有，但是浏览器都支持）HTML &lt;marquee&gt;&lt;/marquee&gt;2、属性 (移动方向)direction=”left/right/up/down”(移动速度)scrollamount=”10”(循环次数)loop=”2”(滚动类型)behavior=”alternate/slide” (来回/一次停住)【inherit】1、麻烦的属性不想再写一遍，在子元素属性添加:inherit（前提：父元素有该属性）【圣杯布局、双飞翼布局】(在1112资料里)1、不用flex能自动缩放2、适用一切浏览器 【垂直水平居中的2种方式】1、绝对定位后 left：50%；top:50%; margin-left:(-width/2)px;2、绝对定位后 left:0;top:0;bottom:0;right:0;margin:auto; (这是特殊方法) 【background-attachment:fixed;】1、背景图做固定定位，移动滚轮才有效果 【快捷写法】1、ul&gt;li{内容} 中括号添加标签里内容2、ul&gt;li.num$*3 生成3个num1 num2 num3类名的li 【兄弟选择器】1、+ 其后一个2、~ 其后全部元素 【::selection】1、鼠标选中文字时，改变选中后的样式 【overflow:hidden是能切割一切盒子外的地方】1、嵌套层的盒子即使相对父盒子绝对定位，父盒子只要设置overflow:hidden；超出盒子范围的任何子元素都会隐藏 z-index设置多大也不会出现。 【对伪对象的hover】1、 * div:hover::after 并不是 div::after:hover 【transform一些特性】1、只要在该标签使用 scale rotate translate 的动作的瞬间，就相当于脱离文档流呈现在最上方，除有z-index&gt;1以外不能覆盖，不然都能覆盖2、变化的时候margin,padding都会根据属性变化发生改变，但不会把原来的位置撑开 **记着变化的瞬间，相当于脱离文档浮在最上面 【transition-origin】1、定的位置要在本元素上写，不要写在:hover上写（这样写起点不断改变） 【transform-style: preserve-3d;】1、三维属性要添加在父级上，里面的元素才可以进入三维空间2、进入三维空间后，如果给父盒子添加维度属性，要按照三维空间去考虑，整体缩放或者移动会得到想要的结果 （eg:scale3d(x,y,z)）3、只要给transform 父盒子 里面的元素都会改变4、旋转都是顺时针为正方向 【@font-face 字体图标】1、小码哥1120 里面有最兼容的方法（第二种）日后就写这种(原理：unicode是字体在网页端最原始的应用方式)(Unicode(统一码、万国码、单一码)是一种在计算机上使用的字符编码) 【媒体查询范围值】1、 PC @media（min-width:981px）{}2、 Pad @media(min-width:621px) and (max-width:980px){}3、 Phone @media(max-width:620px){}4、 日后写媒体查询加上 @media screen (…){…} 加上screen 是保证只给有屏幕的且支持H5的设备观看 【外链媒体查询（提高加载效率）】1、 2、 3、 【响应式网站写CSS】1、写样式的时候尽量把PC的 嵌套写法都写进去，这样保证权重一致，方便日后修改 【position:fixed;被覆盖问题】1、如果都不设置z-index 后面的也会覆盖固定定位的盒子；","tags":[{"name":"HTML，CSS","slug":"HTML，CSS","permalink":"http://yoursite.com/tags/HTML，CSS/"}]}]